This is Info file gnits.info, produced by Makeinfo version 1.68 from
the input file gnits.texi.

START-INFO-DIR-ENTRY
* Gnits: (gnits).                Gnits Standards.
END-INFO-DIR-ENTRY

   Gnits Standards Copyright (C) 1996 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.


File: gnits.info,  Node: Top,  Next: Preface,  Prev: (dir),  Up: (dir)

Version
*******

   Last updated 1996-09-15.

* Menu:

* Preface::                     About the GNU Coding Standards
* Intellectual Property::       Keeping Free Software Free
* Design Advice::               General Program Design
* Program Behavior::            Program Behavior for All Programs
* Writing C::                   Making The Best Use of C
* Documentation::               Documenting Programs
* Managing Releases::           The Release Process

 -- The Detailed Node Listing --

Keeping Free Software Free

* Reading Non-Free Code::       Referring to Proprietary Programs
* Contributions::               Accepting Contributions
* Copyright Notices::           Inserting Copyright Notices

Program Behavior for All Programs

* Semantics::                   Writing robust programs
* Libraries::                   Library behavior
* Errors::                      Formatting error messages
* User Interfaces::             Standards for command line interfaces
* Option Table::                Table of Long Options
* Memory Usage::                When and how to care about memory needs

Standards for Command Line Interfaces

* File Arguments::              File Arguments
* Version Output::              Output of `--version'
* Help Output::                 Output of `--help'

Making The Best Use of C

* Formatting::                  Formatting Your Source Code
* Comments::                    Commenting Your Work
* Syntactic Conventions::       Clean Use of C Constructs
* Names::                       Naming Variables and Functions
* System Portability::          Portability between different operating systems
* CPU Portability::             Supporting the range of CPU types
* System Functions::            Portability and "standard" library functions
* Internationalization::        Techniques for internationalization

Documenting Programs

* GNU Manuals::                 Writing proper manuals.
* Manual Structure Details::    Specific structure conventions.
* NEWS File::                   NEWS files supplement manuals.
* Change Logs::                 Recording Changes
* Man Pages::                   Man pages are secondary.
* Reading other Manuals::       How far you can go in learning
                                from other manuals.
* README file::                 The README File
* AUTHORS file::                The AUTHORS File
* THANKS file::                 The THANKS File

The Release Process

* Configuration::               How Configuration Should Work
* Makefile Conventions::        Makefile Conventions
* Releases::                    Making Releases

Makefile Conventions

* Makefile Basics::             General Conventions for Makefiles
* Utilities in Makefiles::      Utilities in Makefiles
* Command Variables::           Variables for Specifying Commands
* Directory Variables::         Variables for Installation Directories
* Standard Targets::            Standard Targets for Users
* Install Command Categories::  Install Command Categories


File: gnits.info,  Node: Preface,  Next: Intellectual Property,  Prev: Top,  Up: Top

About the Gnits Standards
*************************

   *Note Preface: (standards)Preface.

   The Gnits Standards are a collection of habits, and their
descriptions, willfully chosen by a small group of maintainers calling
themselves the GNU nit-picker gang.  The word `Gnits' refer to the
gang, not the standards they decided to use, even if this little
confusion is quite understandable, and excusable.

   More than a standard, Gnits is a small group of maintainers
interested at nit-picking at others, or being nit-picked by them.  In
fact, it evolved out of a kind and relaxed friendship between a few
maintainers.  We use our little group to let the steam or frustrations
get out, once in a while, and might discuss of many unexpected things,
really, yet usually related to our maintenance work.  The level of
discussion is frank to the point many things would be hardly
publishable... In fact, Gnits is a small group of people having really
*done* a lot of work together for years.  The mailing list quoted below
exists only as a convenience between us.

   The point behind Gnits Standards is that the GNU Standards don't
actually specify *enough* detail.  In a way, Gnits Standards start where
the GNU Standards leave off.  Since Gnits Standards are only meant to
supplement GNU Standards themselves, sometimes to an excruciating level
of detail, we decided to lay out this manual exactly using the same
structure GNU Standards have, just for easing cross referencing from
here to there.  Many sections here are left empty, so the numbering
stays identical in both printed manuals.  When new sections are needed
here, they are added at the end of chapters instead of a place that
might be more logical, only to preserve the numbering correspondence
between sections.

   Let us insist on the fact that Gnits Standards are in no way
normative in GNU.  Only real, genuine GNU Standards are.  GNU
maintainers do not have to follow Gnits Standards if they do not feel
like it.  Nevertheless, they might find in Gnits Standards good ideas
on the way to *follow* GNU Standards themselves, as well as tentative,
non-official explanations about why some GNU Standards were decided the
way they are.

   There are very few discrepancies between Gnits Standards and GNU
Standards, and they are always well noted as such.  So there is very
little chance that, by reading this manual, you would be inadvertently
induced into disobeying GNU Standards.  Moreover, it would be sad if
GNU Standards were massively importing Gnits Standards, and this might
turn off contributors by what they deem to be excessive requirements in
GNU.

   Besides C programming, Gnits Standards want to address problems in
writing shell scripts, `m4' code and Perl scripts.  And many other
things!

   Opinions or suggestions regarding this document may be sent to
`gnits@prep.ai.mit.edu'.  However, please keep in mind this manual just
represents the common choice of a few people only, and is not normative
in the GNU project.  So, there is no real point in trying to deeply
debate Gnits Standards.  Moreover, the `gnits' address is kind of
private, the goal of Gnits Standards is a mean for us to work faster
and nevertheless feel satisfied with the results of our work.  If we
were induced in great debates, or if the `gnits' list was becoming
public, I fear the whole thing would slow us down far more than it
helps.

   If you really feel like contributing to GNU, you might jump in, and
do things yourself.  Consider the GNU tasks list, available for `ftp'
on `prep.ai.mit.edu' in `pub/gnu/standards/' and see if some project
would interest you enough for raising your commitment to it.  Most
projects require a lot of time to achieve successfully.  Write to
`gnu@prep.ai.mit.edu' for involving yourself.

   This release of the Gnits Standards was last updated 1996-09-15.


File: gnits.info,  Node: Intellectual Property,  Next: Design Advice,  Prev: Preface,  Up: Top

Keeping Free Software Free
**************************

   *Note Intellectual Property: (standards)Intellectual Property.

* Menu:

* Reading Non-Free Code::       Referring to Proprietary Programs
* Contributions::               Accepting Contributions
* Copyright Notices::           Inserting Copyright Notices


File: gnits.info,  Node: Reading Non-Free Code,  Next: Contributions,  Prev: Intellectual Property,  Up: Intellectual Property

Referring to Proprietary Programs
=================================

   *Note Reading Non-Free Code: (standards)Reading Non-Free Code.

   GNU should nevertheless keep an eye on what is going on around.  In
general, the GNU project refuses to endorse the use or development or
distribution of non-free software.  We don't do anything to encourage
use of non-free software.  However, this does not mean we don't care
about the languages and data formats used by non-free software.
Interoperation with popular non-free software is an important design
goal for GNU software.  In general, when a non-free program is more
popular than the GNU software, it is very important to make the GNU
software interoperate with the non-free program, so that people who
already use it can more easily switch to GNU.  This is the reason why
the GNU system as a whole is upward-compatible with Unix (letter from
Richard, 1996-06-14).


File: gnits.info,  Node: Contributions,  Next: Copyright Notices,  Prev: Reading Non-Free Code,  Up: Intellectual Property

Accepting Contributions
=======================

   *Note Contributions: (standards)Contributions.

   All GNU packages need to install smoothly and work solidly.  Writing
the installation code and other accoutrements of a package is part of
the job it, just like "writing the program."  It is a matter of whether
the whole job is done.  Offering to contribute a program, but not
offering to follow through by setting up the installation, is not
really a useful way of helping.  If a contributor does part of the job,
and expects to dump the rest of the job on the maintainer, naturally
the maintainer will be annoyed.  And he may well say `I don't have time
for that.'  (letter from Richard, 1996-06-14.)

   One argument that is recurrent, when time comes to request and
obtains assignments from contributors, is that since the code is GPLed
to start with, the GPL wording could be used in court to prove that
additions or derived code is itself GPLed, and as such, does not need
explicit assignment.  We are all harrased with legalese, and try
finding ways to escape it, this is normal.

   In case of an hypothetical court suit against the FSF for copyright
matters, the strength of the copyright, as well as the strength of your
defense, depends on how you were provably interested in defending it in
a day-to-day manner.  If the FSF can prove it always took the copyright
matters seriously, and not only once at the beginning for a package, it
is in a quite better position for defending itself.(1)

   You should never try to adapt legal wording yourself.  If you come to
a situation which isn't exactly one where you know what to do, please
ask Richard, who may have to ask the FSF lawyer what to do (letter from
Richard, 1995-09-19).

   ---------- Footnotes ----------

   (1) This may be contrasted with patents, which never loose their
strength, whatever the holder does or does not to protect them.  You
may get a patent, let everybody offend for 15 years, and then begin to
whirl your axe and reclaim for retroactive damages.  Offenders do not
get stronger to defend themselves, with time.


File: gnits.info,  Node: Copyright Notices,  Prev: Contributions,  Up: Intellectual Property

Inserting Copyright Notices
===========================

   There is no parallel node in GNU Standards.

   Almost all files in a distribution should bear copyright notices at
their beginning, using the appropriate commenting device for that file.
For example, a shell script might begin that way:

     #! /bin/sh
     # ONE-LINE DESCRIPTION OF THE SCRIPT
     # Copyright (C) YEARS Free Software Foundation, Inc.
     # AUTHOR NAME <EMAIL ADDRESS>, INITIAL YEAR.
     
     # This program is free software; you can redistribute it and/or modify
     # it under the terms of the GNU General Public License as published by
     # the Free Software Foundation; either version 2, or (at your option)
     # any later version.
     
     # This program is distributed in the hope that it will be useful,
     # but WITHOUT ANY WARRANTY; without even the implied warranty of
     # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     # GNU General Public License for more details.
     
     # You should have received a copy of the GNU General Public License
     # along with this program; if not, write to the Free Software Foundation,
     # Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

In this example, the very first line (the zeroth line) is mandatory only
because of the shell script nature of the file.  Most files do not need
such a line.

   The first line is a quick description of the purpose of the file,
with maybe some indication for the package this file pertains to.

   The third line might be nearly the only place where you identify
yourself as the author of this file, telling how to reach you, and when
you did start writing this file initially.

   You should put such copylefts on, unless the files are small (letter
from Richard, 1990-04-10).


File: gnits.info,  Node: Design Advice,  Next: Program Behavior,  Prev: Intellectual Property,  Up: Top

General Program Design
**********************

   *Note Design Advice: (standards)Design Advice.


File: gnits.info,  Node: Program Behavior,  Next: Writing C,  Prev: Design Advice,  Up: Top

Program Behavior for All Programs
*********************************

   *Note Program Behavior: (standards)Program Behavior.

* Menu:

* Semantics::                   Writing robust programs
* Libraries::                   Library behavior
* Errors::                      Formatting error messages
* User Interfaces::             Standards for command line interfaces
* Option Table::                Table of Long Options
* Memory Usage::                When and how to care about memory needs


File: gnits.info,  Node: Semantics,  Next: Libraries,  Prev: Program Behavior,  Up: Program Behavior

Writing Robust Programs
=======================

   *Note Semantics: (standards)Semantics.


File: gnits.info,  Node: Libraries,  Next: Errors,  Prev: Semantics,  Up: Program Behavior

Library Behavior
================

   *Note Libraries: (standards)Libraries.


File: gnits.info,  Node: Errors,  Next: User Interfaces,  Prev: Libraries,  Up: Program Behavior

Formatting Error Messages
=========================

   *Note Errors: (standards)Errors.

   Capitalization of error messages is a difficult point.  The trend
seems to be that a complete sentence, ending with a period, should also
start with a capital.  When an error message has a telegraphic style,
is not a complete sentence ending with a period, it might better start
with a lower case letter.

   GNU standards seem to a little fuzzy on this topic, and the
justification for what it suggests is hard to guess.


File: gnits.info,  Node: User Interfaces,  Next: Option Table,  Prev: Errors,  Up: Program Behavior

Standards for Command Line Interfaces
=====================================

   *Note User Interfaces: (standards)User Interfaces.

* Menu:

* File Arguments::              File Arguments
* Version Output::              Output of `--version'
* Help Output::                 Output of `--help'


File: gnits.info,  Node: File Arguments,  Next: Version Output,  Prev: User Interfaces,  Up: User Interfaces

File Arguments
--------------

   About the generic command format:

     COMMAND [OPTION]... [FILE]...

all FILE arguments should all be input files as far as possible, never
output.  Output files should usually be introduced by options.  This is
in GNU standards.  But also, FILE should be the complete file name.
Extension may be added as a facility for when FILE is not found as
written.  But if FILE exists as shown, it should be taken without
adding extensions to it.


File: gnits.info,  Node: Version Output,  Next: Help Output,  Prev: File Arguments,  Up: User Interfaces

Output of `--version'
---------------------

   The `--version' output is meant not only to give the program name,
but to give a precise reference to where the actual sources for the
program can be found.  One asset of GNU is that all sources are
available.  It should never be difficult to discover and grab the
proper sources for any given executable program or script.

   A few maintenance scripts may depend of a rather precise format for
`--version' output, which is now detailed.  The output should consist
of only one line containing many fields separated with a single space.
From left to right, these fields are:

   * The program name, at least when it is different from the package
     name, or when specific program version numbers follow.  When a
     single package distributes many programs, the program name is
     always given.

   * The program version numbers, but only if they differ from the
     version numbers of the whole package.  This happens, rather
     unfrequently, when a single package distributes programs which are
     maintained by different people, each using his own version scheme
     (e.g. the Texinfo distribution).

   * A single dash `-' character, surrounded by one space on each side,
     of course.  This string is used in case both the program name and
     the package name are given.  When only the package and package
     version numbers are given, it is assumed that the program name is
     identical to the package name, and that program version numbers
     are the same as the package version numbers.  In this case, this
     single dash is omitted.

   * The optional word `GNU', all in capitals.

   * The mandatory package name.

   * The mandatory version numbers for the package name.

   If PACKAGE is the package name and VERSION are the package version
numbers, then `PACKAGE-VERSION.tar.gz' should be the exact name of the
archive file containing the distribution, exact even to the
capitalization.

   Here are some examples:

     cat - GNU textutils 1.19c
     msgfmt - GNU gettext 0.10.24
     GNU recode 3.4.2

   We use `-' instead of words like `from', and avoid using the word
`version' between names and numbers, in hope to escape the need of
internationalising `--version' output.


File: gnits.info,  Node: Help Output,  Prev: Version Output,  Up: User Interfaces

Output of `--help'
------------------

   The output of the `--help' option is meant to be a meaningful
reminder of the more comprehensive documentation available for any
single program.  It should be *meaningful* enough to go beyond a crude
list of unexplained option letters.  Even long option names are not
really helpful when completely bare.  It should also be only meant as a
clear, concise, yet complete *reminder*, not trying in any way to
replace the comprehensive documentation or make it unnecessary.
However, users having already read the manual, or having a good level
of familiarity with the program itself, should be usually satisfied with
only the `--help' output, for day to day usage.

   Some programs necessarily have an extensive `--help' output, because
they have really many options, `ls' and `stty' come to mind.  Others
have very few options, like `true'.  Despite these differences, all GNU
programs respecting Gnits Standards have similar behaviour.  The
`--help' output is produced *only* through an explicit usage of the
`--help' option, and is *never* produced as a side-effect of detecting
bad usage, or missing arguments.  The proper behaviour for usage errors
is producing a possible diagnostic on standard error, followed by a
one-line message, still on standard error, saying something like:

     Try `PROGRAM --help' for more information.

with PROGRAM replaced by the program name, of course.  The diagnostic
line preceding the `Try...' line should ideally mention the offending
argument.  It doesn't matter so much interactively, but when debugging
shell scripts, where the arguments might be specified through several
layers of variables and nested calls, it can really help pinpoint the
culprit (letter from Karl, 1994-09-10).

   The `--help' output from various programs should share a similar
structure, which may contain the following items, usually in the order
given:

   * A synopsis of the program call, telling the overall syntax of the
     command.  Suggestions for writing the synopsis are detailed below.

   * A short reminder of the purpose of the program, explaining what it
     basically does, in very few lines.  A single line is best.  The
     synopsis comes first because the explanation may refer to
     variables in the synopsis (letter from Karl, 1995-05-11).  If
     there are many synopsis, they may be referred to by expression
     like `the first form', `the second form', etc.

   * A tabular presentation of all program options.  This is usually
     the bulk of the `--help' output, and is also detailed further down.

   * One or more paragraphs succintly describing default or implied
     values for various options, if not already stated above.  This is
     also where is explained the meaning of missing files, or files
     being `-'.

   * A quick sentence should introduce the main bug reporting address
     for this program, usually a generic bug reporting list, more than
     the individual address of the current maintainer.  Like:

          Report bugs to <bug-gnu-utils@prep.ai.mit.edu>.

     Only for translated versions of this `--help' output, a second
     sentence might tell where to report linguistic problems for this
     translation, usually pointing to a whole translation team rather
     than to the precise author of the translation.

   Here are some more rules applying to the whole `--help' output:

   * There is a difficult equilibrium between concision and clarity, to
     the point writing proper `--help' output is a little art in itself.
     In favor of concision, keep in mind that `--help' output is no more
     than a *reminder*, and never aims to free users from reading the
     full documentation for the program.  Users should feel `--help'
     output is concentrated information, with no verbiage ever in them.
     Clarity should be attained through very careful wording and
     illuminating disposition of the graphical output masses, more than
     through extended explanations.

   * All text is left-justified.  Avoid any centering.  Never ever use
     double left-right justification for avoiding ragged right: with
     fixed width fonts as those use for `--help' output, this is known
     to decrease readability.  Use only single spaces between words in
     sentences, and use exactly two spaces for a full stop, separating
     sentences in a paragraph.  In a word, concision should never go as
     far as squeezing out spaces that are usual in writing text, as
     appropriate for the language being used.

   * The `--help' output should not contain `--version' output (but it
     states the existence and purpose of the `--version' option).
     Since `--help' is usually called interactively, it is not useful to
     overly insist in the output about which program is being
     documented.

   * Logical parts of the `--help' output should be separated with a
     single white line.  Single white lines should also be used
     whenever it is felt their presence would subtantially increase
     readability.

   * Feel comfortable using a tabular presentation for options or
     explanations, and assume that all program output may ask for a
     fixed width font display.  That is, do not care about varying
     width fonts.  However, for moving from one tabular margin to
     another, use only spaces and never <TAB>s, since tabulations are
     not always set the same way on all terminals.

     Also assume user displays have at least 79 characters, by having
     no line in your `--help' output which uses more than 79 characters.

   * Tabulated material should always be introduced by one (or more)
     complete lines, would it be by a single word, like `Options:'.
     Most of non-tabulated text, as well as introduction to tables,
     should use no margin (and start all in column 0).  Tabulated
     material should use an overall sub-margin of two spaces of margin
     (and start in column 2).

   * For tabulated material using two columns, two margins are
     necessary.  The first margin is set after two spaces from the far
     left, as stated above.  The second margin should ideally be set
     exactly three spaces to the right of the rightmost character of
     the left column, yielding the visual impact that both columns are
     solid rectangular blocks separated by a white vertical line having
     three characters of thickness.

     A global table often have many subtables of two columns each, each
     subtable having its short introductory line.  Each subtable should
     be set independantly, with no attempt to line up the second margin
     of all subtables.  Having each subtable having its own second
     margin has the global effect of bolding the overall structure for
     the reader.

   * In tabulated enumerations, use the comma as meaning alternative
     writings, rather than `|' or just spaces.  It's better let the
     user feel that the comma systematically means alternation in all
     our `--help'.  For example:

          The backup suffix is ~, unless set with SIMPLE_BACKUP_SUFFIX.  The
          version control may be set with VERSION_CONTROL, values are:
          
            t, numbered     make numbered backups
            nil, existing   numbered if numbered backups exist, simple otherwise
            never, simple   always make simple backups

   Here are some rules for the synopsis:

   * Begin with `Usage: ', with a mandatory capital, and a space after
     the colon.  If there are several alternative syntaxes, begin the
     other lines with exactly ` or: '.

   * The program name as extracted from `argv[0]'.  Maybe we should
     consider systematically removing the path.

     The GNU standards dictate that most programs should not consider
     `argv[0]' for deciding their behavior.  So it seems also reasonable
     that the name of a program be fixed, whatever its installed name.
     However, using `argv[0]' could help a little users on sites where
     `binprefix' is defined non empty, because a fixed name could be a
     little misleading on these sites.

   * Keep the synopsis simple.  Options will be detailed later, so do
     not detail right away all possible option letters or long names.
     Do not even stress that options start with an hyphen.  Use nothing
     more than `[OPTION]...', after the program name, for announcing
     all options.

   * In the synopsis, use capital letters for representing
     meta-variables and *exact* case for representing the rest.  Do not
     use meta angle brackets for meta-variable.  Do not just cluster
     meta-variables made of many words, as this often make them
     difficult to read.  Use hyphens, rather than underlines, for
     separating words in meta-variable names (prefer `FROM-FILE' over
     `FROM_FILE' or `FROMFILE').  The context is such that there is
     almost no risk of ambiguity, as in practice, the hyphen never
     stands for itself.

     Using hyphens rather than underlines in this context has another
     free advantage: it eases separating between meta-variables and
     environment variables, later down in the `--help' output.

   * Use square brackets for indicating that a parameter is optional,
     use ellipsis (three consecutive dots) after a symbol for
     indicating that it may be repeated one or more time.  For
     indicating it may be repeated zero, one or many times, use
     brackets first, than ellipsis, as in:

          Usage: m4 [OPTION]... [FILE]...

   * Avoid braces, asterisks, plusses, or vertical bars if you can.

   The detailed list of options follow many principles, given here.

   * Every option listed, long or short, must be listed with its
     argument if any (letter from Richard, 1994-03-31).  In fact, the
     description should make clear whether options accept arguments or
     not.  It might not be that useful repeating argument options both
     for short and long forms.  79 characters is often tight, and the
     problems we would create ourselves by spoiling the horizontal
     space needed for repetition is not reasonable.  We could of course
     divert horizontal space into vertical space, somewhat loosing
     density and concision, but this is not a good choice.

     We want to really keep the `--help' output as concise as possible,
     yet being useful.  In practice, this constraint can be a bit
     alleviated by an initial statement to the effect `Mandatory or
     optional arguments to long options are mandatory or optional for
     short options too.' The precise formulation has been much debated,
     yet it is difficult to keep it short.  It really wants to mean
     that `For any long option having a mandatory argument, the
     corresponding short option has a mandatory argument.  For any long
     option allowing an optional argument, the corresponding short
     option allows an optional argument.' Another good sentence would
     be: `If an argument to a long option is mandatory, it's also
     mandatory for the corresponding short option; the same is true for
     optional arguments.'  (letter from Karl, 1995-02-15).

   * When a program has many options, try regrouping options logically,
     instead of listing them all alphabetically (say), as the mere
     regrouping is a succint way to convey much information.  Present
     each group of options in its own subtable, suitably introduced by
     some few words.  Separate groups by white lines for making the
     overall structure more easy to grasp by the reader.  Here is an
     excerpt from a relatively big `--help' output:

          Main operation mode:
            -t, --list              list the contents of an archive
            -x, --extract, --get    extract files from an archive
            -c, --create            create a new archive
            -d, --diff, --compare   find differences between archive and file system
            -r, --append            append files to the end of an archive
            -u, --update            only append files newer than copy in archive
            -A, --catenate          append tar files to an archive
                --concatenate       same as -A
                --delete            delete from the archive (not on mag tapes!)
          
          Device blocking:
            -b, --blocking-factor=BLOCKS   BLOCKS x 512 bytes per record
                --record-size=SIZE         SIZE bytes per record, multiple of 512
            -i, --ignore-zeros             ignore zeroed blocks in archive (means EOF)
            -B, --read-full-records        reblock as we read (for 4.2BSD pipes)

   * Some options have a value.  Put `=' followed by a metavariable for
     the value, after the long option.  If you have to document a short
     option with a value, do not use use such `=', prefer a space for
     the value to be a separate, or nothing if you prefer the value
     clustered with the option.

   * When possible, use imperative sentences to document options'
     effects.

   * Do not describe options that are deprecated, ignored, or useless.


File: gnits.info,  Node: Option Table,  Next: Memory Usage,  Prev: User Interfaces,  Up: Program Behavior

Table of Long Options
=====================

   *Note Option Table: (standards)Option Table.


File: gnits.info,  Node: Memory Usage,  Prev: Option Table,  Up: Program Behavior

Memory Usage
============

   *Note Memory Usage: (standards)Memory Usage.


File: gnits.info,  Node: Writing C,  Next: Documentation,  Prev: Program Behavior,  Up: Top

Making The Best Use of C
************************

   *Note Writing C: (standards)Writing C.

* Menu:

* Formatting::                  Formatting Your Source Code
* Comments::                    Commenting Your Work
* Syntactic Conventions::       Clean Use of C Constructs
* Names::                       Naming Variables and Functions
* System Portability::          Portability between different operating systems
* CPU Portability::             Supporting the range of CPU types
* System Functions::            Portability and "standard" library functions
* Internationalization::        Techniques for internationalization


File: gnits.info,  Node: Formatting,  Next: Comments,  Prev: Writing C,  Up: Writing C

Formatting Your Source Code
===========================

   *Note Formatting: (standards)Formatting.


File: gnits.info,  Node: Comments,  Next: Syntactic Conventions,  Prev: Formatting,  Up: Writing C

Commenting Your Work
====================

   *Note Comments: (standards)Comments.

   Sometimes, code is published while it is known to be suboptimal in
one way or the other.  Maintainers use various ways for leaving a trace
that will later bring their attention to such code sections, usually in
form of some special string they can search for, and which is generally
included in comments.  The `/* FIXME:... */' comment habit comes from
some other GNU package (maybe `gcc' or `gdb'?), using this precise
string (`FIXME' written in capitals, and immediately followed by a
colon) uniformly among Gnits packages makes it more easy to interpret
such comments in our code, or write tools retrieving or recognizing such
comments.  Moreover, using `FIXME:' strings is not limited to C code.
This should be extended to shell or `m4' scripts, `Makefile's, and even
documentation, using for each the commenting device which is
appropriate.

   In a word, not only should we use such `FIXME:' strings to introduce
comments about suboptimal code, but we should be careful at saving such
comments in the code when they come to our mind, for the benefit of
those reading the code and willing to further contribute to code
maintenance.  An alternative is maintaining one or more `TODO' files,
which may be good for generic or global points in maintenance.  For
specific points in code, `FIXME:' strings kept right where they belong,
are more useful.


File: gnits.info,  Node: Syntactic Conventions,  Next: Names,  Prev: Comments,  Up: Writing C

Clean Use of C Constructs
=========================

   *Note Syntactic Conventions: (standards)Syntactic Conventions.

   Do not attempt to put more than 509 bytes into a single string in
your printf calls.  The `509' is taken from the ANSI C standard, and
reflects unfortunate limits in old-fashioned implementations.  The
actual portable limit is considerably larger these days, but it's wise
not to go overboard.  In particular, PDP-11 V7 Unix, MS-DOS and Xenix
MSC, Bruker X32 SYSV3.0 compilers have this problem.

   This is a stringent condition, as many wouldn't trust themselves to
remember to count the characters in the long strings every time an
option is added, the grammar changed, or a typo fixed in a `--help'
message.  I think there are enough long `--help' messages to merit an
automated approach to keeping string lenghts under that limit.  If
avoiding strings longer than 509 characters is that important, perhaps
`gcc' should be able to warn about it (letter from Jim, 1994-03-31).


File: gnits.info,  Node: Names,  Next: System Portability,  Prev: Syntactic Conventions,  Up: Writing C

Naming Variables and Functions
==============================

   *Note Names: (standards)Names.


File: gnits.info,  Node: System Portability,  Next: CPU Portability,  Prev: Names,  Up: Writing C

Portability between System Types
================================

   *Note System Portability: (standards)System Portability.


File: gnits.info,  Node: CPU Portability,  Next: System Functions,  Prev: System Portability,  Up: Writing C

Portability between CPUs
========================

   *Note CPU Portability: (standards)CPU Portability.


File: gnits.info,  Node: System Functions,  Next: Internationalization,  Prev: CPU Portability,  Up: Writing C

Calling System Functions
========================

   *Note System Functions: (standards)System Functions.


File: gnits.info,  Node: Internationalization,  Prev: System Functions,  Up: Writing C

Internationalization
====================

   *Note Internationalization: (standards)Internationalization.

   GNU standards (and GNU in general) make fairly simplistic assumptions
about other languages.  For example, it is said that the plural form is
decided by the number of objects being greater than one, and assume this
`can handle any language, no matter how it forms the plural of the
word...'.  In fact, this is true only for English and a small subset of
all other languages.  A few of us are trying to consider this problem
with broader eyes and mind.


File: gnits.info,  Node: Documentation,  Next: Managing Releases,  Prev: Writing C,  Up: Top

Documenting Programs
********************

   *Note Documentation: (standards)Documentation.

   The main documentation for a package is ideally available in Texinfo
files, expressed either by nicely printed manuals, or by hypertextual
interactive documents.  Parts of this documentation is concentrating on
usage or invocation for every a program of a package, such documentation
should be available through the command `info NAME', given any program
NAME.  A summary of usage may also be requested from the program by
`NAME --help'.  Such usage summaries are also available translated for
various languages.

   This scheme covers most documentation needs, as far as the
information itself is concerned.  However, `man' pages may also be
available for people praising this particular interface.  In *no*
circumstance, `man' pages may convey information which is not also
found in the Texinfo manual.  Texinfo files should always be updated
first, `man' pages second.  Some `man' pages still exist only because
they predated the Texinfo manual, it is usual to just not update them
anymore.

* Menu:

* GNU Manuals::                 Writing proper manuals.
* Manual Structure Details::    Specific structure conventions.
* NEWS File::                   NEWS files supplement manuals.
* Change Logs::                 Recording Changes
* Man Pages::                   Man pages are secondary.
* Reading other Manuals::       How far you can go in learning
                                from other manuals.
* README file::                 The README File
* AUTHORS file::                The AUTHORS File
* THANKS file::                 The THANKS File


File: gnits.info,  Node: GNU Manuals,  Next: Manual Structure Details,  Prev: Documentation,  Up: Documentation

GNU Manuals
===========

   *Note GNU Manuals: (standards)GNU Manuals.

   The Texinfo manual for a package also has the purpose of explain how
and where bugs should be reported.


File: gnits.info,  Node: Manual Structure Details,  Next: NEWS File,  Prev: GNU Manuals,  Up: Documentation

Manual Structure Details
========================

   *Note Manual Structure Details: (standards)Manual Structure Details.

   Avoid using <TAB>s in a Texinfo manual, as they later cause various
problems on the output disposition.  Is alignment of comments in menu
guaranteed using spaces only by now?  If not, it should be considered a
bug: not everybody is using `(setq-default tab-width 8)' in Emacs.

   About node names, we need precise rules about which characters are
allowed, and exactly why characters were forbidden.  Special
characters, like `.' or `+', have been reported to create various
problems to Info readers, rendering nodes inaccessible.  The macro
package `texinfo.tex' also has its limitations, which we should
inventory.


File: gnits.info,  Node: NEWS File,  Next: Change Logs,  Prev: Manual Structure Details,  Up: Documentation

The NEWS File
=============

   *Note NEWS File: (standards)NEWS File.


File: gnits.info,  Node: Change Logs,  Next: Man Pages,  Prev: NEWS File,  Up: Documentation

Change Logs
===========

   *Note Change Logs: (standards)Change Logs.


File: gnits.info,  Node: Man Pages,  Next: Reading other Manuals,  Prev: Change Logs,  Up: Documentation

Man Pages
=========

   *Note Man Pages: (standards)Man Pages.

   If a `man' page is being kept only because it once existed, and is
not being updated anymore, this `man' page should display a warning to
that effect.  Here is a possible text:

     This documentation is no longer being maintained and may be
     inaccurate or incomplete.  The Texinfo documentation is now the
     authoritative source.

   Some packages install man pages by default.  Other packages require
an explicit `make install-man' for getting them installed.  Maybe that
a correct attitude might be to install `man' page by default (that is,
through `make install'), only if they are guaranteed to be up-to-date.
If `man' pages are not up-to-date, there might be no point in
installing them with any `Makefile' target (letter from Karl,
1995-04-24).


File: gnits.info,  Node: Reading other Manuals,  Next: README file,  Prev: Man Pages,  Up: Documentation

Reading other Manuals
=====================

   *Note Reading other Manuals: (standards)Reading other Manuals.


File: gnits.info,  Node: README file,  Next: AUTHORS file,  Prev: Reading other Manuals,  Up: Documentation

The README File
===============

   There is no parallel node in GNU Standards.

   Each distribution ought to contain a `README' file.  This is the
first file an installer should look at and fully read after unpacking a
distribution and prior to configuring it.  All other documentation files
should be referred to, directly or indirectly, from the `README' file.

   If you have something you think the installer of your package
*should* know, make sure the `README' of your package states it.
Assume this file is being read.  Do not try, in particular, to make the
configuration process more verbose, or to otherwise make your your
installation more complex, because you fear installers will not read
`README' files.

   If installers decide to *not* read the `README' file and proceed
directly with installation, this is their own choice and their own risk,
which they shall assume.  Do not take the responsibility of their choice
on your shoulders, nor feel otherwise guilty about it.  Maybe installing
GNU packages had just become far too easy :-).

   For pretest releases *only*, you might also decide to distribute a
file `README-alpha' containing special comments for your friendly
pretesters.  If you decide to follow the version numbering scheme
suggested elsewhere in this document (*note Releases::.), you might
automate its distribution by using the following code in your
`configure.in':

     changequote(,)dnl
     case $VERSION in
       [0-9]*.[0-9]*[a-z]) DIST_ALPHA="README-alpha";;
       [0-9]*.[0-9]*.[0-9]*) DIST_ALPHA="README-alpha";;
       *) DIST_ALPHA=;;
     esac
     changequote([, ])dnl
     AC_SUBST(DIST_ALPHA)

So whenever the version has three parts, or has two parts suffixed by a
single letter, `DIST_ALPHA' would be substituted with `README-alpha',
otherwise left empty.  In your top-level `Makefile.am', just ensure you
have something like:

     EXTRA_DIST = @DIST_ALPHA@


File: gnits.info,  Node: AUTHORS file,  Next: THANKS file,  Prev: README file,  Up: Documentation

The AUTHORS File
================

   There is no parallel node in GNU Standards.

   The AUTHORS file should collect a fairly exact copy of the trace,
normally kept in file `/gd/gnuorg/assignments' on the FSF machines, for
all legal paper exchanges between contributors and the GNU project for
your particular package.  The file might have an introductory blurb
similar to this one:

     Authors of GNU PACKAGE.

     The following contributions warranted legal paper exchanges with
     the Free Software Foundation.  Also see files ChangeLog and THANKS.


File: gnits.info,  Node: THANKS file,  Prev: AUTHORS file,  Up: Documentation

The THANKS File
===============

   There is no parallel node in GNU Standards.

   In Emacs, thanks are not published for the people who just send bug
fixes.  There are too many of them.  The only people thanked are those
who do larger amounts of work.  However, if you find it is OK to thank
them all, that is OK (letter from Richard, 1995-09-20).

   All distributions should contain a `THANKS' file, starting with a
wording similar to this one:

     GNU PACKAGE THANKS file

     GNU PACKAGE has originally been written by ORIGINAL AUTHOR.  Many
     people further contributed to GNU PACKAGE by reporting problems,
     suggesting various improvements or submitting actual code.  Here
     is a list of these people.  Help me keep it complete and exempt of
     errors.

   followed by a two column lists of contributors, one per line,
alphabetically sorted.  The left column gives the contributor's name,
while the right column gives the last known good electronic address for
this contributor.

   You can also decide to send some kind of special greeting(1) when
you initially add a name to your `THANKS' file.  The mere presence of a
name in `THANKS' is then a flag to you that the initial greeting has
been sent.

   Another good habit is to never put an electronic address in
`ChangeLog', only in `THANKS'.  So, when someone requests that his
email address be updated, this only has to be done in one place.
`ChangeLog' always quotes the full name(2) of all contributors for each
change, introduced by the expression `From' or `Reported by'.  Those
two files combined are very useful when you need to revise an area you
do not know well, but which some users do.  You can then construct
special purpose mailing lists of provably interested people, for solving
together some specific problems.  This has been useful more than once.

   ---------- Footnotes ----------

   (1) An initial greeting might, for example, invite the person to
become a pretester, and might explain how to do so.  Some dedicated
pretesters of today started with a minor contribution.

   (2) Full names usually never change.  This happened only once to our
knowledge, when Michael Innis Bushnell became Thomas Bushnell.


File: gnits.info,  Node: Managing Releases,  Prev: Documentation,  Up: Top

The Release Process
*******************

   *Note Managing Releases: (standards)Managing Releases.

* Menu:

* Configuration::               How Configuration Should Work
* Makefile Conventions::        Makefile Conventions
* Releases::                    Making Releases


File: gnits.info,  Node: Configuration,  Next: Makefile Conventions,  Prev: Managing Releases,  Up: Managing Releases

How Configuration Should Work
=============================

   *Note Configuration: (standards)Configuration.


File: gnits.info,  Node: Makefile Conventions,  Next: Releases,  Prev: Configuration,  Up: Managing Releases

Makefile Conventions
====================

   *Note Makefile Conventions: (standards)Makefile Conventions.

* Menu:

* Makefile Basics::             General Conventions for Makefiles
* Utilities in Makefiles::      Utilities in Makefiles
* Command Variables::           Variables for Specifying Commands
* Directory Variables::         Variables for Installation Directories
* Standard Targets::            Standard Targets for Users
* Install Command Categories::  Install Command Categories


File: gnits.info,  Node: Makefile Basics,  Next: Utilities in Makefiles,  Prev: Makefile Conventions,  Up: Makefile Conventions

General Conventions for Makefiles
---------------------------------

   *Note Makefile Basics: (standards)Makefile Basics.


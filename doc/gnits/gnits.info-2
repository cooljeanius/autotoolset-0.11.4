This is Info file gnits.info, produced by Makeinfo version 1.68 from
the input file gnits.texi.

START-INFO-DIR-ENTRY
* Gnits: (gnits).                Gnits Standards.
END-INFO-DIR-ENTRY

   Gnits Standards Copyright (C) 1996 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.


File: gnits.info,  Node: Utilities in Makefiles,  Next: Command Variables,  Prev: Makefile Basics,  Up: Makefile Conventions

Utilities in Makefiles
----------------------

   *Note Utilities in Makefiles: (standards)Utilities in Makefiles.

   We have to segregate between *installer* goals and *maintainer*
goals in `Makefile's.  The same division applies to shell scripts.  I
think GNU maintainers should make every effort so `all', `install' and
`uninstall' be fully portable.  Those `Makefile' rules representing an
installer goal, as well as `configure' files or subsidiary scripts, may
not use non-`sh' commands, nor programs outside a specific set.
"Installer goals" and "installer scripts" satisfy the needs of any
straight *out-of-the-box* configuration, compilation, checking and
installation of a GNU package.  We should also try making honest
efforts so installers be able to do modify genuine C sources, or other
simple source files, and complete a reinstallation by using nothing
else than installer goals.

   However, some other goals require special tools.  For example, `dvi'
requires `TeX' and `texi2dvi'.  Goals meant specifically meant for
maintainers, like `dist', may rely on many GNU programs, like GNU
`tar', GNU `date', GNU `make' maybe, who knows, and surely, a proper
shell.  The maintainer has a lot of freedom, here.  If your shell is
improper while `dist' works for the maintainer using GNU `bash', this
should not be perceived as a bug.  Installers may have to acquire and
install proper tools.  `dist' is surely not a goal meant for usual
installers of GNU packages, and does not need to show the same level of
portability as usual goals, it does not have to take care for all and
every broken situation out there.  If a script or rule uses commands or
programs outside the prescribed set, it has to be related to a
maintainer goal.  "Maintainer goals" and "maintainer scripts" allow for
modification of a Texinfo source, a Bison grammar, `configure.in', any
`Makefile.am', or in fact, any other kind of genuine source from which
distributed files were derived by the maintainer.  Installers may not
just modify *anything* in a GNU distribution, and still expect a
reinstallation without any special tools pre-installed first.

   GNU packages might show unequal complexity in the source
dependencies.  It would be preferrable that all goals be available to
all installer, of course, yet maintainer goals should not be redesigned
as installer goals at the expense of the maintainability of the package.

   A few shell constructs call for further comments, given a bit
randomly, here.

`echo'
`false'
`true'
     These may be processed especially by some shells, and also
     available as separate programs.  We consider the later hypothesis,
     and rather discuss these in the table following this one, below.

   The allowable set of programs is repeated in full below, as most of
these programs call for further comments.

`cat'
     No options allowed.

`cmp'
     Always use with option `-s' and depend on the return status, not
     on the fact output was produced or not.

`cp'
`mv'
     No options allowed.

`diff'

`echo'
     No options allowed.  Do not depend on special escape sequences,
     which are not equally supported in all `echo's.  In particuler,
     never use `\c' for preventing the new line at the end of echoed
     text.

     There is a feature by which, when `echo' has many arguments, they
     are all echoed one after the other, separated by a single space.
     It looks neater to us when this feature is not abused.  Prefer
     using a single argument with the proper spacing included, even if
     this means using surrouding quotes.  It also better prepares
     scripts for later internationalization.  For example, the second
     line below should be preferred:

          echo Some famous last words:
          echo 'Some famous last words:'

     If you really need to control suppression new lines, you might
     have to configure out explicitly how `echo' behaves.  This surely
     requires some doing, so it might often be simple to just avoid the
     need if you can.  Here is how `shar' does it in its generated
     archive scripts (the trick originated in Autoconf):

          if (echo "testing\c"; echo 1,2,3) | grep c >/dev/null; then
            if (echo -n testing; echo 1,2,3) | sed s/-n/xn/ | grep xn >/dev/null; then
              shar_n= shar_c='
          '
            else
              shar_n=-n shar_c=
            fi
          else
            shar_n= shar_c='\c'
          fi

     and usage of `echo', once configuration done, looks like:

          echo $shar_n 'Question [no, yes] (no)?' $shar_c

     Internationalization of shell scripts is closely related to usage
     of `echo'.

`expr'
     You should not use the pattern matching facilities of `expr',
     which are not as universal as its arithmetic capabilities.  If you
     need matching only for recognizing patterns, without any
     substitution, merely base your code on the `case' construct of
     Bourne shells.  If you need pattern matching with substitution,
     rather use `sed'.

`grep'
`egrep'
     The only allowable option is `-v'.

`install-info'

`ln'
     No options allowed.

`ls'

`mkdir'
`rmdir'
     No options allowed.

`pwd'
     No options allowed.

`rm'
     The only allowable option are `-f' and `-r'.  The `-f' option
     should be preferred over using a `-' before the `rm' call in a
     `Makefile' action (for suppressing the examination of the return
     code).

`sed'
     Usage of semi-colons in `sed' scripts for separating successive
     `sed' commands is explicitely allowed.  Autoconf already use this
     feature, bearing the experience that this is portable.

`sleep'

`sort'

`tar'

`test'
     Never, ever use the `[' form of the `test' program or shell
     construct in portable scripts or `Makefile's.

     Allowable options for testing strings are `-n', `-z', `!=' and
     `='.  It is not allowable to have `-n' implied by the mere
     presence of a string, the `-n' has to be explicitly written.
     Allowable options for testing files are `-f', `-r' and `-w'.

     Option `-x', for checking if a file is executable, is not available
     on all systems; use `-f' instead and not `-r', as executable files
     are not even necessarily readable.

     Options `-a' and `-o', implementing logical connectives, are not
     universally available either, and not always implemented the same
     way respective to priorities.  Use shell logical connectives
     instead.  For example, the two following lines are usually
     equivalent, yet the second form should always be preferred:

          if test -f README -a -f NEWS; then
          if test -f README && test -f NEWS; then

`touch'
     No options allowed.

`true'
`false'
     The program `true' is not really needed, and the `sh' construct
     `:' does just as well, so `true' is to be avoided in practice.
     Automake complies with this part of Gnits Standards.

     We also think that `false' can be completely avoided.  Please try
     avoiding it.


File: gnits.info,  Node: Command Variables,  Next: Directory Variables,  Prev: Utilities in Makefiles,  Up: Makefile Conventions

Variables for Specifying Commands
---------------------------------

   *Note Command Variables: (standards)Command Variables.


File: gnits.info,  Node: Directory Variables,  Next: Standard Targets,  Prev: Command Variables,  Up: Makefile Conventions

Variables for Installation Directories
--------------------------------------

   *Note Directories Variables: (standards)Directories Variables.

   Some standards installation directories are worth more comments.

`bindir'
     There is seemingly no standard directory for specifying
     architecture-independent programs, like `$(prefix)/bin)' would
     (letter from Tom, 1996-04-24).  Further discussion on the Gnits
     list indicates that architecture-independent programs are rare
     enough that this omission is not really a problem.

`includedir'
     Very few packages contain machine-specific header files, so it is
     not sure whether we need a convention for them.
     `$(prefix)/includes' is for all header files.  There is no
     convention for any other place to install them (letter from
     Richard, 1996-02-14).


File: gnits.info,  Node: Standard Targets,  Next: Install Command Categories,  Prev: Directory Variables,  Up: Makefile Conventions

Standard Targets for Users
--------------------------

   *Note Standard Targets: (standards)Standard Targets.

   A few standard `Makefile' goals are worth more comments.

`all'
     Despite what GNU standards say, many maintainers are quite
     attentive to *not* use `-g' while linking.  On a few systems
     (Linux in particular), this creates binaries unable to take
     advantage of shared libraries when later installed, yielding
     unacceptably big binaries.  Also see `install-strip' below.

`install'
     This goal should be further subdivided in `install-exec' and
     `install-data'.  On sites having mixed CPU architectures,
     `install-exec' should install everything which is architecture
     specific, while `install-data' should install files common to all
     architectures.  When installing on multiple architectures after
     the first, this would avoid having to rewrite all the `.info'
     files, etc., on arches after the first (letter from Karl,
     1995-05-13).  Of course, making `install' is equivalent to
     installing everything at once.  Automake complies with this part
     of Gnits Standards.

     For installing Info files, GNU standards mandate using:

          -if test -f foo.info; then d=.; \
          else d=$(srcdir); fi; \

     which is only useless complexity.  Info file are always generated
     in the source directories because they are meant to be later
     distributed all prepared: they *ought* to be, per GNU standards.
     These lines were introduced as an half-hearted attempt to handle
     hypothetical cases of read-only distributions (thinking about
     CD-ROMs).  These two lines have been confusing to many
     maintainers, who tried generalising them, introducing various
     other bugs and contradictions on the way.  Richard Stallman more
     or less agrees it was an error to have this trickery in GNU
     standards, but is reluctant to remove it, because he says it hurts
     nothing and he has more urgent things to do (yet he easily spent,
     arguing, many hundred times the energy it would have taken to kill
     the lines).

     Info files installation per GNU standards has another huge
     ugliness: it asks us to write rules relying on an unexisting, or
     at least unavailable, `install-info' program.  Such programs are
     being written by people, and later rejected by the FSF for various
     reasons (wrong specifications, wrong implementation language,
     wrong legalese, etc.)  While this is being done and undone,
     demands to maintainers through GNU standards are changing, and we
     kept updating our `Makefile.in's and Texinfo files for no real
     purpose.  Some of us are loosing time at conformance, while the
     matter is not even set.  But by now, it seems that members of
     Gnits just does not call `install-info', and provide, near the
     beginning of each Texinfo file, the image of the suggested `dir'
     menu items like this:

          @ifinfo
          @format
          START-INFO-DIR-ENTRY
          * DIRENTRY-1
          * DIRENTRY-2
          ...
          END-INFO-DIR-ENTRY
          @end format
          @end ifinfo

     The DIRENTRY lines, which really are menu items, ideally give easy
     pointers for the whole package, as well as one per program the
     package installs (so the command `info NAME' works).

     Richard Stallman has supposedly been writing a new `install-info'
     program, accompanied by changes to Texinfo so we might write
     instead:

          @dircategory <whatever> (we'll have to dream up a list of categories)
          @direntry
          * DIRENTRY-1
          * DIRENTRY-2
          ...
          @end direntry

     (letter from Karl, 1996-09-09).

     In the meantime, we do not bracket `dir' entries in support of an
     always evanescent `install-info' program.  We are just not
     interested at working right away at improving the functionality of
     hurded software.  Let it become available first!

     However, just consider that it is a good idea that every maintainer
     use some brackets as a uniform way to *document* the set of `dir'
     entries they want to suggest for their package.  This purpose is
     acceptable.  Let's stick to `START-INFO-DIR-ENTRY' and
     `END-INFO-DIR-ENTRY', until a working solution gets *fully*
     available to the GNU community.  In this particular case, it seems
     that the mere statement in GNU standards brought us nowhere, and
     slowly.

`install-strip'
     This goal should of course supported for mere compliance, yet it
     is not very useful as designed.  GNU standards speak of `Users who
     don't mind being helpless' and `Devil-may-care users', and this
     biased wording and thinking let us guess that GNU standards did
     not overly try being helpful at it.  Nearly everybody prefer *all*
     their binaries installed stripped by default, so there is an
     alternative mechanism in Gnits that installers might like.

     In their environment, they may permanently setup at login time some
     definitions, using code similar to this one (`sh' syntax):
          export INSTALL_DATA; INSTALL_DATA='install -m 644'
          export INSTALL_PROGRAM; INSTALL_PROGRAM='install -m 755 -s'
          export INSTALL_SCRIPT; INSTALL_SCRIPT='install -m 755'

     so the default behaviour they want is enforced automatically, and
     without ugly diagnostics while installing scripts.  Automake
     complies with this part of Gnits Standards.

`clean'
`distclean'
`maintainer-clean'
     It seems that many of us have difficulty understanding exactly
     where a particular derived file should be removed.  Here are some
     practical rules which would help taking such decisions.

        * If `make all' did it, `make clean' removes it.

        * If `./configure' did it, `make distclean' removes it.

        * If *you* did it, `make maintainer-clean' removes it :-).

     The `distclean' goal, in spirit, is for bringing a distribution
     back to distribution state.  This is a useful goal people should
     use before reconfiguring a directory for a different architecture,
     but it is less useful when people are using different build
     directories, one per architecture, when their `make' permits of
     course.  As for the `maintainer-clean' goal, it is *not* for users
     and installers, generally.  You may need fairly special tools to
     reshape a distribution after a `maintainer-clean'.  Some
     installers stubbornly insist for using it, and submit reports
     about it.  Please, let it plainly be their problem.  By
     considering their reports, you are encouraging the abuse.

     As parallel `make' goes, we want all the `mostlyclean's from done
     before all the `clean's, themselves before all the `distclean's.
     Dependencies over some configuration files like `config.status'
     force us to be very careful at removing them only last, especially
     when recursive `make' is involved.  Automake complies with this
     part of Gnits Standards.

     GNU Standards require a bit of interpretation, here.  If Richard
     put that (`ID' and) `TAGS' should be removed in `maintainer-clean',
     this is only because he traditionally packaged a ready `TAGS' in
     his own distributions, so it would not make sense removing these in
     `distclean' if this goal should merely bring back the package to
     distribution state.

     However, if `ID' and `TAGS' are *not* being distributed, as it
     seems to be the current trend, these have to be built after the
     unpacking, so removing them within `distclean' makes perfect sense,
     and the GNU Standards are just a bit oldish on these things.

     I wonder how difficult it would be for Automake to know somewhat
     whether `ID' or `TAGS' are meant to be distributed in a package,
     or not, and decide where to remove these, accordingly.

`check'
     Programs which are only used by the `check' goal should only be
     built when actually checking (letter from Tom, 1996-01-24).
     Automake offers the `check_PROGRAMS' macro for making this easy.

     One possibility for `make check' is to use DejaGNU.  Properly
     written DejaGNU test suites can be run even when the program is
     cross-compiled, by copying the program to an appropriate host and
     running there (letter from Tom, 1996-01-24).  But DejaGNU requires
     TCL, so checking through DejaGNU is fairly demanding, and put
     `make check' more among the maintainer goals than among the
     installer goals.  Automake offers alternate means so it is
     possible to write checks available to all installers.  We should
     prefer, and by far, offering `make check' as an installer goal.

`id'
`tags'
`ID'
`TAGS'
     A goal named `id' should have `ID' as its sole dependency, so the
     command `make id' will regenerate the project's `ID' file.  A goal
     named `tags' should have `TAGS' as its sole dependency, so the
     command `make tags' will regenerate the project's `TAGS' file.

     In a distribution having a shallow or deep directory structure,
     `ID' and `TAGS' files may be generated in more than one
     subdirectory.  At the top-level, a global `TAGS' should be
     generated which uses the "include" feature for making all tags
     available at once.  Automake currently implements this solution,
     which is satisfying so far.

     GNU Standards do not speak of `ID' at all.  GNU Standards are
     unclear, or at least fuzzy, about the fact `TAGS' should be part of
     distributions or not.  Gnits members do not read GNU Standards all
     the same way on this particular aspect.

     It seems that the current trend is to *not* distribute `ID' and
     `TAGS' files, but leave goals so the installer can rebuild them
     easily, if needed.  Whether a package distributes `TAGS', it should
     also distribute `ID'.  If it does not distribute `TAGS', it should
     not distribute `ID' either.

     We may question the utility of distributing pre-made `ID' or
     `TAGS' files.  People using them will be programmers.  Programmers
     who know what to do with an `ID' file will have `mkid'
     installed--in fact, one can't even use an `ID' file unless `mkid'
     (and therefore `lid') is installed.  People who use `TAGS' will be
     `emacs'-users, and will therefore have `etags' installed, and
     they'll know how to type `make TAGS'.  So, in the interest of
     fighting distribution bloat, we don't think either `ID' or `TAGS'
     files should be in the distribution (letter from Greg, 1996-02-20).


File: gnits.info,  Node: Install Command Categories,  Prev: Standard Targets,  Up: Makefile Conventions

Install Command Categories
--------------------------

   *Note Install Command Categories: (standards)Install Command
Categories.


File: gnits.info,  Node: Releases,  Prev: Makefile Conventions,  Up: Managing Releases

Making Releases
===============

   *Note Releases: (standards)Releases.

   Various releases of a given packages are distinguished by their
version numbers.  Versions are usually made up by two or three decimal
numbers, separated by periods.  An officially released package ideally
has two numbers, a pretest release often have either three numbers or
two numbers immediately suffixed with a small case letter.  Versions
should be *increasing* as time goes, for example, acceptable successions
might be:

     1.0
     1.1
     1.2
     1.2.1
     1.2.2
     1.2.3
     1.2.4
     1.3
     1.3.1
     1.4

or maybe:

     ...
     3.17
     3.17a
     3.17b
     3.17c
     3.18

   A much simplified statement of the overall goal is that the following
recipe should usually work, when one wants to install any GNU package on
his Unix systems.

     % ftp prep.ai.mit.edu
     ftp> anonymous
     ftp> USER@FULLY.QUALIFIED.DOMAIN
     ftp> binary
     ftp> cd pub/gnu
     ftp> get PACKAGE-VERSION.tar.gz
     ftp> bye
     % tar xfz PACKAGE-VERSION.tar.gz
     % cd PACKAGE-VERSION
     % cat README
     % ./configure
     % make check install

   Of course, variations are endless for both maintainers and
installers, but a nice goal is trying to prepare things so that the
recipe above does something sensible, as stated.



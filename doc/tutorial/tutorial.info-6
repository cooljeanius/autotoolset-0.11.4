This is tutorial.info, produced by makeinfo version 4.3 from
tutorial.texi.

INFO-DIR-SECTION Miscellaneous
START-INFO-DIR-ENTRY
* Autotoolset Tutorial: (tutorial).        Autotools tutorial.
END-INFO-DIR-ENTRY


File: tutorial.info,  Node: Handling Embedded text,  Next: Handling very deep packages,  Prev: Invoking acmkdir,  Up: Using Autotools

Handling Embedded text
======================

   In some cases, we want to embed text to the executable file of an
application.  This may be on-line help pages, or it may be a script of
some sort that we intend to execute by an interpreter library that we
are linking with, like Guile or Tcl. Whatever the reason, if we want to
compile the application as a stand-alone executable, it is necessary to
embed the text in the source code. Autotools provides with the build
tools necessary to do this painlessly.

   As a tutorial example, we will write a simple program that prints
the contents of the GNU General Public License. First create the
directory tree for the program:
     % acmkdir copyleft

Enter the directory and create a copy of the `txtc' compiler:
     % cd copyleft-0.1
     % mktxtc

Then edit the file `configure.in' and add a call to the `LF_PROG_TXTC'
macro. This macro depends on
     AC_PROG_CC
     AC_PROG_AWK

so make sure that these are invoked also. Finally add `txtc.sh' to your
`AC_OUTPUT'.  The end-result should look like this:
     AC_INIT(reconf)
     AM_CONFIG_HEADER(config.h)
     AM_INIT_AUTOMAKE(copyleft,0.1)
     LF_HOST_TYPE
     LF_CONFIGURE_CC
     LF_CONFIGURE_CXX
     LF_SET_OPTIMIZATION
     LF_SET_WARNINGS
     AC_PROG_RANLIB
     AC_PROG_AWK
     LF_PROG_TXTC
     AC_OUTPUT(Makefile txtc.sh doc/Makefile m4/Makefile src/Makefile)

Then, enter the `src' directory and create the following files:
     % cd src
     % gpl -l gpl.txt
     % gpl -cc gpl.h
     % gpl -cc copyleft.cc

The `gpl.txt' file is the text that we want to print. You can substitute
it with any text you want. This file will be compiled into `gpl.o'
during the build process. The `gpl.h' file is a header file that gives
access to the symbols defined by `gpl.o'. The file `copyleft.cc' is
where the `main' will be written.

   Next, add content to these files as follows:
*gpl.h*
          extern int gpl_txt_length;
          extern char *gpl_txt[];

*copyleft.cc*
          #ifdef HAVE_CONFIG_H
          #include <config.h>
          #endif
          
          #include <iostream.h>
          #include "gpl.h"
          
          main()
          {
           loop(i,1,gpl_txt_length)
           { cout << gpl_txt[i] << endl; }
          }

*Makefile.am*
          SUFFIXES = .txt
          .txt.o:
                 $(TXTC) $<
          
          bin_PROGRAMS = copyleft
          foo_SOURCES = copyleft.cc gpl.h gpl.txt

and now you're set to build. Go back to the toplevel directory and go
for it:
     $ cd ..
     $ reconf
     $ configure
     $ make
     $ src/copyleft | less

To verify that this works properly, do the following:
     $ cd src
     $ copyleft > copyleft.out
     $ diff gpl.txt copyleft.out

The two files should be identical.  Finally, convince yourself that you
can make a distribution:
     $ make distcheck

and there you are.

   Note that in general the text file, as encoded by the text compiler,
will not be always identical to the original. There is one and only one
modification being made: If any line has any blank spaces at the end,
they are trimmed off.  This feature was introduced to deal with a bug
in the Tcl interpreter, and it is in general a good idea since it
conserves a few bytes, it never hurts, and additional whitespace at the
end of a line shouldn't really be there.

   This magic is put together from many different directions. It begins
with the `LF_PROG_TXTC' macro:
*LF_PROG_TXTC*
     This macro will define the variable `TXTC' to point to a Text-to-C
     compiler. To create a copy of the compiler at the toplevel
     directory of your source code, use the `mktxtc' command:
          % mktxtc

     The compiler is implemented as a shell script, and it depends on
     `sed', `awk' and the C compiler, so you should call the following
     two macros before invoking `AC_PROG_TXTC':
          AC_PROG_CC
          AC_PROG_AWK

     The compiler is intended to be used as follows:
          $(TXTC) text1.txt text2.txt text3.txt ...

     such that given the files `text1.txt', `text2.txt', etc.  object
     files `text1.o', `text2.o', etc, are generated that contains the
     text from these files.

From the Automake point of view, you need to add the following two lines
to Automake:
     SUFFIXES = .txt
     .txt.o:
             $(TXTC) $<

assuming that your text files will end in the `.txt' suffix. The first
line informs Automake that there exist source files using non-standard
suffixes. Then we describe, in terms of an abstract Makefile rule, how
to build an object file from these non-standard suffixes. Recall the
use of the symbol `$<'. Also note that it is not necessary to use
`$(srcdir)' on `$<' for VPATH builds.  If you embed more than one type
of files, then you may want to use more than one suffixes. For example,
you may have `.hlp' files containing online help and `.scm' files
containing Guile code. Then you want to write a rule for each suffix as
follows:
     SUFFIXES = .hlp .scm
     .hlp.o:
             $(TXTC) $<
     .scm.o:
             $(TXTC) $<

It is important to put these lines before mentioning any `SOURCES'
assignments. Automake is smart enough to parse these abstract makefile
rules and recognize that files ending in these suffixes are valid source
code that can be built to object code. This allows you to simply list
`gpl.txt' with the other source files in the `SOURCES' assignment:
     copyleft_SOURCES = copyleft.cc gpl.h gpl.txt

In order for this to work however, Automake must be able to see your
abstract rules first.

   When you "compile" a text file `foo.txt' this makes an object file
that defines the following two symbols:
     int foo_txt_length;
     char *foo_txt[];

Note that the dot characters are converted into underscores. To make
these symbols accessible, you need to define an appropriate header file
with the following general form:
     extern int foo_txt_length;
     extern char *foo_txt[];

When you include this header file into your other C or C++ files then:
   * You can obtain the filename containing the original text from
          foo_txt[0];

     and use it to print diagnostic messages.

   * You can obtain the text itself line by line:
          char *foo_txt[1];   -> first line
          char *foo_txt[2];   -> second line
          ...

   * The last line is set to NULL and `foo_txt_length' is defined such
     that
          char *foo_txt[foo_txt_length+1] == NULL

     The last line of the text is:
          char *foo_txt[foo_txt_length];

     You can use a `for' loop (or the `loop' macro defined by
     LF_CPP_PORTABILITY) together with `foo_txt_length' to loop over
     the entire text, or you can exploit the fact that the last line
     points to `NULL' and do a `while' loop.
   and that's all there is to it.


File: tutorial.info,  Node: Handling very deep packages,  Prev: Handling Embedded text,  Up: Using Autotools

Handling very deep packages
===========================

   When making a package, you can organize it as a "flat" package or a
"deep" package. In a flat package, all the source files are placed
under `src' without any subdirectory structure. In a deep package,
libraries and groups of executables are seperated by a subdirectory
structure. The perennial problem with deep packages is dealing with
interdirectory dependencies. What do you do if to compile one library
you need header files from another library in another directory? What
do you do if to compile the test suite of your library you need to link
in another library that has just been compiled in a different directory?

   One approach is to just put all these interdependent things in the
same directory. This is not very unreasonable since the `Makefile.am'
can document quite thoroughly where each file belongs, in case you need
to split them up in the future. On the other hand, this solution
becomes less and less preferable as your project grows. You may not
want to clutter a directory with source code for too many different
things. What do you do then?

   The second approach is to be careful about these dependencies and
just invoke the necessary features of Automake to make everything work
out.

   For `*.a' files (library binaries), the recommended thing to do is
to link them by giving the full relative pathname. Doing that allows
Automake to work out the dependencies correctly accross multiple
directories.  It also allows you to easily upgrade to shared libraries
with Libtool.  To retain some flexibility it may be best to list these
interdirectory link sequences in variables and then use these
variables. This way, when you move things around you minimize the
amount of editing you have to do.  In fact, if all you need these
library binaries for is to build a test suite you can simply assign
them to `LDFLAGS'. To make these assignments more uniform, you may want
to start your pathnames with `$(top_builddir)'.

   For `*.h' files (header files), you can include an
     INCLUDES = -I../dir1 -I../dir2 -I../dir3 ...

assignment on every `Makefile.am' of every directory level listing the
directories that contain include files that you want to use. If your
directory tree is very complicated, you may want to make these
assignments more uniform by starting your pathnames from
`$(top_srcdir)'.  In your source code, you should use the syntax
     #include "foo.h"

for include files in the current directory and
     #include <foo.h>

for include files in other directories.

   There is a better third approach, provided by Autotools, but it only
applies to include files. There is nothing more that can be done with
library binaries; you simply have to give the path. But with header
files, it is possible to arrange at configure-time that all header
files are symlinked under the directory `$(top_builddir)/include'. Then
you will only need to list one directory instead of many.

   Autotools provides two Autoconf macros: `LF_LINK_HEADERS' and
`LF_SET_INCLUDES', to handle this symlinking.
*LF_LINK_HEADERS*
     This macro links the public header files under a certain set of
     directories under an include directory from the toplevel. A simple
     way to invoke this macro is by listing the set of directories that
     contain public header files:
          LF_LINK_HEADERS(src/dir1 src/dir2 src/dir3 ... src/dirN)

     When this macro is invoked for the first time, the directory
     `$(top_srcdir)/include' is erased. Then for each directory
     `src/dirK' listed, we look for the file `src/dirK/Headers' and
     link the public header files mentioned in that file under
     `$(top_srcdir)/include'. The link will be either symbolic or hard,
     depending on the capabilities of your operating system. If
     possible, a symbolic link will be prefered.

     You can invoke the same macro by passing an optional argument that
     specifies a directory name. For example:
          LF_LINK_HEADERS(src/dir1 src/dir2 ... src/dirN , foo)

     Then the symlinks will be created under the
     `$(top_srcdir)/include/foo' directory instead. This can be
     significantly useful if you have very many header files to install
     and you'd like to call them something like:
          #include <foo/file1.h>

     During compilation, when you try to

*LF_SET_INCLUDES*
     This macro will cause the `Makefile.am' variable
     `$(default_includes)' to contain the correct collection of `-I'
     flags, such that the include files are accessible. If you invoke
     it with no arguments as
          LF_SET_INCLUDES

     then the following assignment will take place:
          default_includes = -I$(prefix) -I$(top_srcdir)/include

     If you invoke it with arguments:
          LF_SET_INCLUDES(dir1 dir2 ... dirN)

     then the following assignment will take place instead:
          default_includes = -I$(prefix) -I$(top_srcdir)/include/dir1 \
                             -I$(top_srcdir)/include/dir2 ...         \
                             -I$(top_srcdir)/include/dirN

     You may use this variable as part of your `INCLUDES' assignment in
     your `Makefile.am' like this:
          INCLUDES = $(default_includes)

     If your distribution has a `lib' directory, in which you install
     various codelets and header files, then a path to that library is
     added to `default_includes' also. In that case, you have one of
     the following:
          default_includes = -I$(prefix) -I$(top_srcdir)/lib -I$(top_srcdir)/include

     or
          default_includes = -I$(prefix) -I$(top_srcdir)/lib \
                             -I$(top_srcdir)/include/dir1 ... \
                             -I$)top_srcdir)/include/dirN

   A typical use of this system involves invoking
     LF_LINK_HEADERS(src/dir1 src/dir2 ... src/dirN)
     LF_SET_INCLUDES

in your `configure.in' and adding the following two lines in your
`Makefile.am':
     INCLUDES = $(default_includes)
     EXTRA_DIST = Headers

The variable `$(default_includes)' will be assigned by the `configure'
script to point to the Right Thing. You will also need to include a
file called `Headers' in every directory level that you mention in
`LF_LINK_HEADERS' containing the public header files that you wish to
symlink. The filenames need to be separated by carriage returns in the
`Headers' file. You also need to mention these public header files in a
     include_HEADERS = foo1.h foo2.h ...

assignment, in your `Makefile.am', to make sure that they are installed.

   With this usage, other programs can access the installed header files
as:
     #include <foo1.h>

Other directories within the same package can access the uninstalled yet
header files in exactly the same manner. Finally, in the same directory
you should access the header files as
     #include "foo1.h"

This will force the header file in the current directory to be
installed, even when there is a similar header file already installed.
This is very important when you are rebuilding a new version of an
already installed library. Otherwise, building might be confused if
your code tries to include the already installed, and not up-to-date,
header files from the older version.

   Alternatively, you can categorize the header files under a directory,
by invoking
     LF_LINK_HEADERS(src/dir1 src/dir2 , name1)
     LF_LINK_HEADERS(src/dir3 src/dir4 , name2)
     LF_SET_INCLUDES(name1 name2)

in your `configure.in'. In your `Makefile.am' files you still add the
same two lines:
     INCLUDES = $(default_includes)
     EXTRA_DIST = Headers

and maintain the `Headers' file as before. However, now the header files
will be symlinked to subdirectories of `$(top_srcdir)/include'.  This
means that although uninstalled header files in all directories must be
included by code in the same directory as:
     #include "header.h"

code in other directories must access these uninstalled header files as
     #include <name1/header.h>

if the header file is under `src/dir1' or `src/dir2' or as
     #include <name2/header.h>

if the header file is under `src/dir3' or `src/dir4'.  It follows that
you probably intend for these header files to be installed
correspondingly in such a manner so that other programs can also
include them the same way. To accomplish that, under `src/dir1' and
`src/dir2' you should list the header files in your `Makefile.am' like
this:
     name1dir = $(includedir)/name1
     name1_HEADERS = header.h ...

and under `src/dir3' and `src/dir4' like this:
     name2dir = $(includedir)/name2
     name2_HEADERS = header.h

One disadvantage of this approach is that the source tree is modified
during configure-time, even during a VPATH build. Some may not like
that, but it suits me just fine.  Unfortunately, because Automake
requires the GNU compiler to compute dependencies, the header files
need to be placed in a constant location with respect to the rest of
the source code. If a `mkdep' utility were to be distributed by
Automake to compute dependencies when the installer installs the
software and not when the developer builds a source code distribution,
then it would be possible to allow the location of the header files to
be dynamic. If that development ever takes place in Automake, Autotools
will immediate follow. If you really don't like this, then don't use
this feature.

   Usually, if you are installing one or two header files per library
you want them to be installed under `$(includedir)' and be includable
with
     #include <foo.h>

On the other hand, there are many applications that install a lot of
header files, just for one library. In that case, you should put them
under a prefix and let them be included as:
     #include <prefix/foo.h>

Examples of libraries doing this X11 and Mesa.

   This mechanism for tracking include files is most useful for very
large projects. You may not want to bother for simple homework-like
throwaway hacks. When a project starts to grow, it is very easy to
switch.


File: tutorial.info,  Node: C++ and Autoconf,  Next: Fortran with Autoconf,  Prev: Using Autotools,  Up: Top

C++ and Autoconf
****************

   In this chapter I will discuss in extreme detail the portability
issues with C++. Most of this work will be based on `bzconfig' which I
will adapt to include in Autotools eventually. I don't know the
structure of this chapter yet.


File: tutorial.info,  Node: Fortran with Autoconf,  Next: Maintaining Documentation,  Prev: C++ and Autoconf,  Up: Top

Fortran with Autoconf
*********************

* Menu:

* Introduction to Fortran support::
* Fortran compilers and linkage::
* Walkthrough a simple example::
* The gory details::
* Portability problems with Fortran::


File: tutorial.info,  Node: Introduction to Fortran support,  Next: Fortran compilers and linkage,  Prev: Fortran with Autoconf,  Up: Fortran with Autoconf

Introduction to Fortran support
===============================

   This chapter is devoted to Fortran. We will show you how to build
programs that combine Fortran and C or C++ code in a portable manner.
The main reason for wanting to do this is because there is a lot of
free software written in Fortran. If you browse
`http://www.netlib.org/' you will find a repository of lots of old,
archaic, but very reliable free sources.  These programs encapsulate a
lot of experience in numerical analysis research over the last couple
of decades, which is crucial to getting work done.  All of these sources
have been written in Fortran. As a developer today, if you know other
programming languages, it is unlikely that you will want to write
original code in Fortran. You may need, however, to use legacy Fortran
code, or the code of a neighbour who still writes in Fortran.

   The most portable way to mix Fortran with your C/C++ programs is to
translate the Fortran code to C with the `f2c' compiler and compile
everything with a C/C++ compiler. The `f2c' compiler is available at
`http://www.netlib.org/' but as we will soon explain, it is also
distributed with the `autotools' package. Another alternative is to use
the GNU Fortran compiler `g77' with `g++' and `gcc'. This compiler is
portable among many platforms, so if you want to use a native Fortran
compiler without sacrificing portability, this is one way to do it.
Another way is to use your OS's native Fortran compiler, which is
usually called `f77', *if* it is compatible with `g77' and `f77'.
Because performance is also very important in numerical codes, a good
strategy is to prefer to use the native compiler if it is compatible,
and support `g77' as a fall-back option. Because many sysadmins don't
install `g77' supporting `f2c' as a third fall-back is also a good idea.

   Autotools provides support for configuring and building source code
written in part or in whole in Fortran. The implementation is based on
the build system used by GNU Octave, which has been generalized for use
by any program.


File: tutorial.info,  Node: Fortran compilers and linkage,  Next: Walkthrough a simple example,  Prev: Introduction to Fortran support,  Up: Fortran with Autoconf

Fortran compilers and linkage
=============================

   The traditional Hello world program in Fortran looks like this:
     c....:++++++++++++++=
           PROGRAM MAIN
           PRINT*,'Hello World!'
           END

All lines that begin with `c' are comments. The first line is the
equivalent of `main()' in C. The second line says hello, and the third
line indicates the end of the code. It is important that all command
lines are indented by 7 spaces, otherwise the compiler will issue a
syntax error. Also, if you want to be ANSI compliant, you must write
your code all in caps. Nowadays most compilers don't care, but some may
still do.

   To compile this with `g77' (or `f77') you do something like:
     % g77 -o hello hello.f
     % hello

To compile it with the f2c translator:
     % f2c hello.f
     % gcc -o hello hello.c -lf2c -lm

where `-lf2c' links in the translator's system library.  In order for
this to work, you will have to make sure that the header file `f2c.h'
is present since the translated code in `hello.c' includes it with a
statement like
     #include "f2c.h"

which explicitly requires it to be present in the current working
directory.

   In this case, the `main' is written in Fortran. However most of the
Fortran you will be using will actually be subroutines and functions.
A subroutine looks like this:
     c....:++++++++++++++
           SUBROUTINE FHELLO (C)
           CHARACTER *(*) C
           PRINT*,'From Fortran: ',C
           RETURN
           END

This is the analog of a `void' function in C, because it takes
arguments but doesn't return anything. The prototype declaration is
"K&R" style: you list all the arguments in parenthesis, seperated with
commas, and you declare the types of the variables in the subsequent
lines.

   Suppose that this subroutine is saved as `fhello.f'. To call it from
C you need to know what it looks like from the point of the C compiler.
To find out type:
     % f2c -P fhello.f
     % cat fhello.P

You will find that this subroutine has the following prototype
declaration:
     extern int fhello_(char *c__, ftnlen c_len);

It may come as a surprise, and this is a moment of revelation, but
although in Fortran it appears that the subroutine is taking _one_
argument, in C it appears that it takes *two*! And this is what makes
it difficult to link code in a portable manner between C and Fortran. In
C, everything is what it appears to be. If a function takes two
arguments, then this means that down to the machine language level,
there is two arguments that are being passed around. In Fortran, things
are being hidden from you and done in a magic fashion. The Fortran
programmer thinks that he is passing one argument, but the compiler
compiles code that actually passes two arguments around. In this
particular case, the reason for this is that the argument you are
passing is a string. In Fortran, strings are not null-terminated, so
the `f2c' compiler passes the length of the string as an extra hidden
argument. This is called the "linkage method" of the compiler.
Unfortunately, linkage in Fortran is not standard, and there exist
compilers that handle strings differently. For example, some compilers
will prepend the string with a few bytes containing the length and pass
a pointer to the whole thing. This problem is not limitted to strings.
It happens in many other instances.  The `f2c' and `g77' compilers
follow compatible linkage, and we will use this linkage as the _ad-hoc
standard_. A few proprietary Fortran compilers like the Dec Alpha `f77'
and the Irix `f77' are also `f2c'-compatible. The reason for this is
because most of the compiler developers derived their code from `f2c'.
So although a standard was not really intended, there we have one
anyway.

   A few things to note about the above prototype declaration is that
the symbol `fhello' is in lower-case, even though in Fortran we write
everything uppercase, and it is appended with an underscore. On some
platforms, the proprietary Fortran compiler deviates from the `f2c'
standard either by forcing the name to be in upper-case or by omitting
the underscore. Fortunately, these cases can be detected with Autoconf
and can be worked around with conditional compilation. However, beyond
this, other portability problems, such as the strings issue, are too
involved to deal with and it is best in these cases that you fall back
to `f2c' or `g77'.  A final thing to note is that although `fhello'
doesn't return anything, it has return type `int' and not `void'. The
reason for this is that `int' is the default return type for functions
that are not declared. Therefore, to prevent compilation problems, in
case the user forgets to declare a Fortran function, `f2c' uses `int'
as the return type for subroutines.

   In Fortran parlance, a "subroutine" is what we'd call a `void'
function. To Fortran programmers in order for something to be a
"function" it has to return something back. This reflects on the syntax.
For example, here's a function that adds two numbers and returns the
result:
     c....:++++++++++++++++
           DOUBLE PRECISION FUNCTION ADD(A,B)
           DOUBLE PRECISION A,B
           ADD = A + B
           RETURN
           END

The name of the function is also the name of the return variable.  If
you run this one through `f2c -P' you will find that the C prototype is:
     extern doublereal add_(doublereal *a, doublereal *b);

There's plenty of things to note here:
   * The typenames being used are funny. `doublereal'? what's that!?
     These are all defined in a header file called `f2c.h' which you are
     supposed to include in your source code before declaring any
     prototypes.  We will show you how this is all done in the next
     section. The following table showes the types that are most likely
     to interest you. For more info, take a look at the `f2c.h' file
     itself:
            integer         -> int
            real            -> float
            doublereal      -> double
            complex         -> struct { real r,i; };
            doublecomplex   -> struct { doublereal r,i; };

   * The arguments are passed by pointer. In Fortran all arguments are
     passed by reference. The `f2c' compiler implements this by passing
     the arguments by pointer. On the C/C++ level you may want to wrap
     the fortran routine with another routine so that you don't have to
     directly deal with pointers all of the time.

   * The value returned now is not an `int' but `doublereal'.  Of
     course, the name of the function is lower-case, as always, and
     there is an underscore at the end.

   A more interesting case is when we deal with complex numbers.
Consider a function that multiplies two complex numbers:
     c....:++++++++++++++++++++++++++++++
           COMPLEX*16 FUNCTION MULT(A,B)
           COMPLEX*16 A,B
           MULT = A*B
           RETURN
           END

As it turns out, the prototype for this function is:
     extern Z_f mult_(doublecomplex *ret_val, doublecomplex *a, doublecomplex *b);

Because complex numbers are not a native type in C, they can not be
returned efficiently without going through at least one copy.
Therefore, for this special case the return value is placed as the
first argument in the prototype!  Actually despite many people's
feelings that Fortran must die, it is still the best tool to use to
write optimized functions that are heavy on complex arithmetic.


File: tutorial.info,  Node: Walkthrough a simple example,  Next: The gory details,  Prev: Fortran compilers and linkage,  Up: Fortran with Autoconf

Walkthrough a simple example
============================

   Now that we have brought up some of the issues about Fortran
linkage, let's show you how to work around them. We will write a simple
Fortran function, and a C program that calls it, and then show you how
to turn these two into a GNU-like package, enhanced with a configure
script and the works.  This discussion assumes that you have installed
the utilities in `autotools', the package with which this tutorial is
being distributed.

   First, begin by building a directory for your new package. Because
this project will involve Fortran, you need to pass the `-f' flag to
`acmkdir':
     % acmkdir -t fortran foo

The `-t' flag directs `acmkdir' to unpack a copy of the `f2c'
translator and to build proper toplevel `configure.in' and
`Makefile.am' files. This will take a while, so relax and stretch a
little bit.

   Now enter the `foo-0.1' directory and look around:
     % cd foo-0.1
     % cat configure.in
     AC_INIT
     AM_CONFIG_HEADER(config.h)
     AM_INIT_AUTOMAKE(hello,0.1)
     LF_CONFIGURE_CC
     LF_CONFIGURE_CXX
     AC_PROG_RANLIB
     LF_HOST_TYPE
     LF_PROG_F77_PREFER_F2C_COMPATIBILITY
     dnl LF_PROG_F77_PREFER_NATIVE_VERSION
     LF_PROG_F77
     LF_SET_WARNINGS
     AC_CONFIG_SUBDIRS(fortran/f2c fortran/libf2c)
     AC_OUTPUT([Makefile fortran/Makefile f2c_comp
             doc/Makefile m4/Makefile src/Makefile ])
     
     % cat Makefile.am
     EXTRA_DIST = reconf configure
     SUBDIRS = fortran m4 doc src

There are some new macros in `configure.in' and a new subdirectory:
`fortran'. There is also a file that looks like a shell script called
`f2c_comp.in'.  We will discuss the gory details about all this in the
next section.  Now let's write the code. Enter the `src' directory and
type:
     $ cd src
     $ mkf2c

This creates the following files:
`f2c.h'
     This is the header file that we alluded to in the previous
     section. It needs to be present on all directory levels that
     contain Fortran code.  It defines all the funny typenames that
     appear in `f2c' compatible prototype declarations.

`f2c-main.c'
     This file contains some silly definitions. You need to link it in
     whenever you link together a program, but don't add it to various
     libraries, because then, when you link some of the libraries
     together you will get error messages for duplicate symbols.  The
     contents of this file are:
          #ifdef __cplusplus
          extern "C" {
          #endif
          
          #if defined (sun)
          int MAIN_ () { return 0; }
          #elif defined (linux) && defined(__ELF__)
          int MAIN__ () { return 0; }
          #endif
          
          #ifdef __cplusplus
          }
          #endif

Now, time to write some code:
     $ vi fhello.f
     $ vi hello.cc

with
`fhello.f'
          c....:++++++++++++++++++++++++++++++
                SUBROUTINE FHELLO (C)
                CHARACTER *(*) C
                PRINT*,'From Fortran: ',C
                RETURN
                END

`hello.cc'
          #ifdef HAVE_CONFIG_H
          #include <config.h>
          #endif
          #include <string.h>
          #include "f2c.h"
          #include "f77-fcn.h"
          
          extern "C"
          {
           extern int f77func(fhello,FHELLO)(char *c__, ftnlen c_len);
          }
          
          main()
          {
           char s[30];
           strcpy(s,"Hello world!");
           f77func(fhello,FHELLO)(s,ftnlen(strlen(s)));
          }

The definition of the `f77func' macro is included in `acconfig.h'
automatically for you if the `LF_CONFIGURE_FORTRAN' macro is included
in your `configure.in'. The definition is as follows:
     #ifndef f77func
     #if defined (F77_APPEND_UNDERSCORE)
     #  if defined (F77_UPPERCASE_NAMES)
     #    define f77func(f, F) F##_
     #  else
     #    define f77func(f, F) f##_
     #  endif
     #else
     #  if defined (F77_UPPERCASE_NAMES)
     #    define f77func(f, F) F
     #  else
     #    define f77func(f, F) f
     #  endif
     #endif
     #endif

Recall that we said that the issue of whether to add an underscore and
whether to capitalize the name of the routine can be dealt with
conditional compilation. This macro is where this conditional
compilation happens.  The `LF_PROG_F77' macro will define
     F77_APPEND_UNDERSCORE
     F77_UPPERCASE_NAMES

appropriately so that `f77func' does the right thing.

   To compile this, create a `Makefile.am' as follows:
     SUFFIXES = .f
     .f.o:
             $(F77) -c $<
     
     bin_PROGRAMS = hello
     hello_SOURCES = hello.cc fhello.f f2c.h f2c-main.c
     hello_LDADD = $(FLIBS)

Note that the above `Makefile.am' is only compatible with version 1.3
of Automake, or newer versions. The previous versions don't grok
Fortran filenames on the `hello_SOURCES' so you may want to upgrade.

   Now you can compile and run the program:
     $ cd ..
     $ reconf
     $ configure
     $ make
     $ src/hello
      From Fortran: Hello world!

If you have a native `f77' compiler that was used, or the portable
`g77' compiler you missed out the coolness of using `f2c'.  In order to
check _that_ out do:
     $ make distclean
     $ configure --with-f2c
     $ make

and witness the beauty! The package will begin by building an `f2c'
binary for your system. Then it will build the Fortran libraries. And
finally, it will build the hello world program which you can run as
before:
     $ src/hello

It may seem an overkill to carry around a Fortran compiler. On the
other hand you will find it very convenient, and the `f2c' compiler
isn't really that big. If you are spoiled on a system that is well
equiped and with a good system administrator, you may find it a nasty
surprise one day when you discover that the rest of the world is not
necessarily like that.

   If you download a real Fortran package from Netlib you might find it
very annoying having to enter the filenames for all the Fortran files in
`*_SOURCES'. A work-around is to put all these files in their own
directory and then do this `awk' trick:
     % ls *.f | awk '{ printf("%s ", $1) }' > tmp

The awk filter will line-up the output of `ls' in one line. You can use
your editor to insert its contents to your `Makefile.am'. Eventually I
may come around to write a utility for doing this automagically.


File: tutorial.info,  Node: The gory details,  Next: Portability problems with Fortran,  Prev: Walkthrough a simple example,  Up: Fortran with Autoconf

The gory details
================

   The best way to get started is by building the initial directory
tree with `acmkdir' like this:
     % acmkdir -t fortran <directory-filename>

This will install all the standard stuff. It will also install a
directory called `fortran' containing a copy of the f2c compiler and
`f2c_comp', a shell script invoking the compiler in a way that it looks
the same as invoking a real compiler

   The file `configure.in' uses the following special macros:
*LF_PROG_F77_PREFER_F2C_COMPATIBILITY*
     This macro directs Autoconf that the user prefers `f2c'
     compatibility over performance. In general Fortran programmers are
     willing to sacrifice everything for the sake of performance.
     However, if you want to use Fortran code with C and C++ code, you
     will have many reasons to also give importance to `f2c'
     compatibility. Use this macro to state this preference. The effect
     is that if the installer's platform has a native Fortran compiler
     installed, it will be used only if it is `f2c' compatible. This
     macro must be invoked before invoking `LF_PROG_F77'.

*LF_PROG_F77_PREFER_NATIVE_VERSION*
     This macro directs Autoconf that the user prefers performance and
     doesn't care about `f2c' compatibility. You may want to invoke this
     instead if your entire program is written in Fortran.  This macro
     must be invoked before invoking `LF_PROG_F77'.

*LF_PROG_F77*
     This macro probes the installer platform for an appropriate Fortran
     compiler. It exports the following variables to Automake:
    `F77'
          The name of the Fortran compiler

    `FFLAGS'
          Flags for the Fortran compiler

    `FLIBS'
          The link sequence for the compiler runtime libraries It also
     checks whether the compiler appends underscores to the symbols and
     whether the symbols are written in lowercase or uppercase
     characters and defines the following preprocessor macros:
    `F77_APPEND_UNDERSCORE'
          Define if the compiler appends an underscore to the symbol
          names.

    `F77_UPPERCASE_NAMES'
          Define if the compiler uses uppercase for symbol names.
     These macros are used to define `f77func' macro which takes two
     arguments; the name of the Fortan subroutine or function in lower
     case, and then in upper case, and returns the correct symbol name
     to use for invoking it from C or C++. To obtain the calling
     sequence for the symbol do:
          % f2c -P foo.f

     on the file containing the subroutine and examine the file `foo.P'.
     In order for this macro to work properly you must precede it with
     calls to
          AC_PROG_CC
          AC_PROG_RANLIB
          LF_HOST_TYPE

     You also need to call one of the two `*_PREFER_*' macros. The
     default is to prefer `f2c' compatibility.  In addition to invoking
all of the above, you need to make provision for the bundled fortran
compiler by adding the following lines at the end of your
`configure.in':
     AC_CONFIG_SUBDIRS(fortran/f2c fortran/libf2c)
     AC_OUTPUT([Makefile fortran/Makefile f2c_comp
                doc/Makefile m4/Makefile src/Makefile])

The `AC_CONFIG_SUBDIRS' macro directs `configure' to execute the
configure scripts in `fortran/f2c' and `fortran/libf2c'.  The stuff in
`AC_OUTPUT' that are important to Fortran support are building
`fortran/Makefile' and `f2c_comp'. Because, `f2c_comp' is mention in
`AC_OUTPUT', Automake will automagically bundle it when you build a
source code distribution.

   If you have originally set up your directory tree for a C or C++ only
project and later you realize that you need to also use Fortran, you can
upgrade your directory tree to Fortran as follows:
   * Create the `fortran' directory by invoking
          % mkfortran

     and the `f2c_oomp' by invoking
          % mkf2c_comp

     both on the toplevel directory level.

   * Add the following macro invokations in the middle of
     `configure.in', in this order:
          AC_PROG_CC
          AC_PROG_RANLIB
          LF_HOST_TYPE
          LF_PROG_F77_PREFER_F2C_COMPATIBILITY
          LF_PROG_F77

     If you have invoked `LF_CONFIGURE_CC' then there is no need to
     invoke `AC_PROG_CC' again.

   * Add the following invokation just before `AC_OUTPUT':
          AC_CONFIG_SUBDIRS([fortran/f2c fortran/libf2c])

     and add the following files to `AC_OUTPUT':
          fortran/Makefile f2c_comp

   * Rebuild with
          % make distclean
          % ./reconf
          % ./configure
          % make

     It is important to call `reconf' for the changes to take effect.

   If a directory level contains Fortran source code, then it is
important to let Automake know about it by adding the following lines
in the beginning.
     SUFFIXES = .f
     .f.o:
             $(F77) -c $<

This is pretty much the same idea with the embedded text compiler.  You
can list the Fortran source code filenames in the `SOURCES' assignments
together with your C and C++ code. To link executables, you must add
`$(FLIBS)' to `LDADD' and link against `f2c-main.c' just as in the
hello world example. Please do not include `f2c-main.c' in any
libraries however.

   Now consider the file `hello.cc' line by line.  First we include the
standard configuration stuff:
     #ifdef HAVE_CONFIG_H
     #include <config.h>
     #endif
     #include <string.h>

Then we include the Fortran related header files:
     #include "f2c.h"

Then we declare the prototypes for the Fortran subroutine:
     extern "C"
     {
      extern int f77func(fhello,FHELLO)(char *c__, ftnlen c_len);
     }

There is a few things to note here:
   * You should never ever declare Fortran prototypes in header files.
     The definition of prototypes is dependent on the `f77func' macro,
     which is dependent on a correct definition of the
     `F77_APPEND_UNDERSCORE' and `F77_UPPERCASE_NAMES' C preprocessor
     macros. You should be nice and not force people who don't want to
     use Fortran to have to get these macros defined in order to use
     your header files.  If you want to export functionality written in
     Fortran to C users, then wrap the Fortran subroutines and
     functions with corresponding C subroutines and functions and
     export these instead on your header file.

   * You should never use the actual name of the Fortran routine in C,
     because doing so is not portable. Instead you should use the
     `f77func' macro, which takes two arguments: the name of the
     routine in small letters, and the name of the routine in all-caps.
     The right name of the two is chosen, and the underscore is
     appended if necessary.

   * If the source file in which you are writing down the Fortran
     declarations is compiled with a C++ compiler, as is true in this
     case, then you must surround the declarations with:
          extern "C"
          {
          }

     The C++ language uses "name mangling" to support function
     overloading.  This means that if you have two C++ functions called:
          int foo(double x);
          int foo(double x,double y);

     the C++ compiler internally assigns them different names in an
     intelligent fashion to avoid conflict. Just like the Fortran
     compiler does things behind your back, so does the C++ compiler to
     support some of its special features. Any code written between
     `extern "C"' is compiled with name mangling disabled. This is
     necessary for the Fortran declarations because we don't want the
     names of the Fortran subroutines to be mangled.

   * When we actually invoke the Fortran subroutine in the `main' we
     make sure to type-cast all the types to what appears on the
     prototype above. In this case we do:
          f77func(fhello,FHELLO)(s,ftnlen(strlen(s)));

     This may seem pedantic but it is necessary for the C++ compiler,
     and it is a good habit even for C programmers. Since Fortran
     routines are supposed to be wrapped, this is not too much to ask.

   * You need to be very careful with integers. On some systems `long
     int' is 64 bit and `int' is 32 bit. This means that you should
     avoid `long int' like the plague! The safest way to deal with
     integers is to make sure that you always cast your integer stuff
     to `integer' explicitly. Unfortunately the standard header file
     distributed with `f2c' defines `integer' as `long int' to account
     for 16-bit machines. That's a bad idea, and on the 64-bit Dec
     Alpha it is a bug. The header file distributed with `mkf2c' does
     the right thing.

   * Make sure to list both `f2c.h' and `f2c-main.c' in `SOURCES'
     assignments on your `Makefile.am' to make sure that they are
     included in the source code distribution.


File: tutorial.info,  Node: Portability problems with Fortran,  Prev: The gory details,  Up: Fortran with Autoconf

Portability problems with Fortran
=================================

   Fortran is infested with portability problems. There exist two
important Fortran standards: one that was written in 1966 and one that
was written in 1977. The 1977 standard is considered to be _the_
standard Fortran.  Most of the Fortran code is written by scientists
who have never had any formal training in computer programming. As a
result, they often write code that is dependent on vendor-extensions to
the standard, and not necessarily easy to port. The standard itself is
to blame as well, since it is sorely lacking in many aspects. For
example, even though standard Fortran has both `REAL' and `DOUBLE
PRECISION' data types (corresponding to `float' and `double') the
standard only supports single precision complex numbers (`COMPLEX').
Since many people will also want double precision complex numbers, many
vendors provided extensions. Most commonly, the double precision
complex number is called `COMPLEX*16' but you might also see it called
`DOUBLE COMPLEX'.  Other such vendors extensions include providing a
`flush' operation of some sort for file I/O, and other such esoteric
things.

   To make things worse (or better) now there are two more standards
out there: the 1990 standard and the 1995 standard. A 2000 standard is
also at work.  Fortran 90 and its successors try to make Fortran more
like C and C++, and even though _there are no free compilers_ for both
variants, they are becoming alarmingly popular with the scientific
community.  In fact, I think that the main reason why these variants of
Fortran are being developed is to make more bussiness for proprietary
compiler developers. So far as I know, Fortran 90 does not provide any
features that C++ can not  support with a class library extension.
Moreover Fortran 90 does not have the comprehensive foundation that
allows C++ to be a self-extensible language. This makes it less
worthwhile to invest effort on Fortran 90, because it means that
eventually people will want features that can only be implemented by
redefining the language and rewriting the compilers for it. Instead, in
C++, you can add features to the language simply by writing C++ code,
because it has enough core features to allow virtually unlimited
self-extensibility.

   If your primary interest is portability and free software, you
should stay away from Fortran 90 as well as Fortran 95, until someone
writes a free compiler for them.  You will be better off developing in
`C++' and only migrating to Fortran 77 the parts that are performance
critical. This way you get the best of both worlds.

   On the flip side, if you limit your Fortran code just to
number-crunching, then it becomes much easier to write portable code.
There are still a few things you should take into account however.
Some Fortran code has been written in the archaic 1966 style. An example
of such code is the `fftpack' package from `netlib'. The main problems
with such code are the following:
   * *Implicit types*: In Fortran 66, programmers were too lazy to
     define the types of their variables.  The idea was that the type
     was inferred by the first letter of the variable name. That's
     horror for you! The convention then is that all variables with
     initial `I,J,...,N' are type `INTEGER'. All others are `REAL' To
     compile this code with modern compilers it is necessary to add the
     following line to every source file:
          IMPLICIT DOUBLE PRECISION (A-H,O-Z)

     This instructs the compiler to do the right thing, which is to
     implicitly assume that all variables starting with `A-H' and `O-Z'
     are double precision and all other variables are integers.
     Alternatively you can say
          IMPLICIT REAL (A-H,O-Z)

     but it is very rarely that you will ever want to go with single
     precision.  Occasionally, you may find that the programmer breaks
     the rules. For example, in `fftpack' the array `IFAC' is supposed
     to be a `double' even though implicitly it is suggested to be an
     `int'. Such inconstances will probably show up in compiler errors.
     To fix them, declare the type of these variables explicitly. If
     it's an array then you do it like this:
          DOUBLE PRECISION IFAC(*)

     If the variable also appears in a `DIMENSION' declaration, then you
     should remove it from the declaration since the two can't coexist
     in _some_ compilers.

   * *Pseudo-pointers*: In archaic Fortran, a dimension declaration of
     the form:
          DIMENSION C(1)

     means that `C' has an unknown length, instead of meaning that it
     has length 1. In modern Fortran, this is an unacceptable notation
     and modern compilers do get confused over it. So all such
     instances must be replaced with the correct form which is:
          DIMENSION C(*)

     Such "arrays" in reality are just pointers. The user can reference
     the array as far as he likes, but of course, if he takes it too
     far, the program will either do the Wrong Thing or crash with a
     segmentation fault.

   * *Constants*: A most insidious problem has to do with constants and
     it is confined, to the best of my knowledge, to the GNU Fortran
     compiler, but it could very well be a problem in other compilers
     to which I have no access to.  Constants tend to appear in `DATA'
     statements or variable assignments.  The problem is that whenever
     a constant is in use, the context is never a determining factor
     for the "type" of the constant, unlike C which does automatic
     casting. Examples: `1' is always type `INTEGER',
     `9.435784839284958' is always type `REAL' (even if the additional
     precision specified is lost, and even when used in a `DOUBLE
     PRECISION' context such as being assigned to a `DOUBLE PRECISION'
     variable!). On the other hand, `1E0' is always `REAL' and `1D0' is
     always `DOUBLE PRECISION'.  If you want your code to be
     exclusively double precision, then you should scan the entire
     source for constants, and make sure that they all have the `D0'
     suffix at the end. Many compilers will tolerate this omission while
     others will not and go ahead and introduce single precision error
     to your computations leading to hard to find bugs.

   In general the code in `http://www.netlib.org/' is very reliable and
portable, but you do need to keep your eyes open for little problems
like the above.


This is toolsmanual.info, produced by makeinfo version 4.2 from
toolsmanual.texi.

INFO-DIR-SECTION Development
START-INFO-DIR-ENTRY
* toolsmanual: (toolsmanual).      Developing software with GNU
END-INFO-DIR-ENTRY


File: toolsmanual.info,  Node: Configuring GNU Emacs,  Next: Using vi emulation,  Prev: Basic Emacs concepts,  Up: Using GNU Emacs

Configuring GNU Emacs
=====================

   To use Emacs effectively for software development you need to
configure it.  Part of the configuration needs to be done in your
X-resources file.  On a Debian GNU/Linux system, the X-resources can be
configured by editing
     /etc/X11/Xresources

In many systems, you can configure X-resources by editing a file called
`.Xresources' or `.Xdefaults' on your home directory, but that is
system-dependent. The configuration that I use on my system is:
     ! Emacs defaults
     emacs*Background: Black
     emacs*Foreground: White
     emacs*pointerColor: White
     emacs*cursorColor: White
     emacs*bitmapIcon: on
     emacs*font: fixed
     emacs*geometry: 80x40

In general I favor dark backgrounds and `fixed' fonts. Dark backgrounds
make it easier to sit in front of the monitor for a prolonged period of
time. `fixed' fonts looks nice and it's small enough to make efficient
use of your screenspace. Some people might prefer larger fonts however.

   When Emacs starts up, it looks for a file called `.emacs' at the
user's home directory, and evaluates it's contents through the Emacs
Lisp interpreter. You can customize and modify Emacs' behaviour by
adding commands, written in Emacs Lisp, to this file. Here's a brief
outline of the ways in which you can customize Emacs:

  1. A common change to the standard configuration is assigning "global
     variables" to non-default values. Many Emacs features and
     behaviours can be controlled and customized this way.  This is
     done with the `setq' command, which accepts the following syntax:
          (setq VARIABLE VALUE)

     For example:
          (setq viper-mode t)

     You can access on-line documentation for global variables by
     running:
          M-x describe-variable

  2. In some cases, Emacs depends on the values of shell "environment
     variables". These can be manipulated with `setenv':
          (setenv "VARIABLE" "VALUE")

     For example:
          (setenv "INFOPATH" "/usr/info:/usr/local/info")

     `setenv' does not affect the shell that invoked Emacs, but it does
     affect Emacs itself, and shells that are run under Emacs.

  3. Another way to enhance your Emacs configuration is by modifying the
     global keymap. This can be done with the `global-set-key' command,
     which follows the following syntax:
          (global-set-key [KEY SEQUENCE] 'FUNCTION)

     For example, adding:
          (global-set-key [F12 d] 'doctor)

     to `.emacs' makes the key sequence `F12 d' equivalent to running
     `M-x doctor'. Emacs has many functions that provide all sorts of
     features. To find out about specific functions, consult the `Emacs
     user manual'. Once you know that a function exists, you can also
     get on-line documentation for it by running:
          M-x describe-function

     You can also write your own functions in Emacs Lisp.

  4. It is not always good to introduce bindings to the global map. Any
     bindings that are useful only within a certain mode should be
     added only to the local keymap of that mode. Consider for example
     the following Emacs Lisp function:
          (defun texi-insert-@example ()
            "Insert an @example @end example block"
            (interactive)
            (beginning-of-line)
            (insert "\n@example\n")
            (save-excursion
              (insert "\n")
              (insert "@end example\n")
              (insert "\n@noindent\n")))

     We would like to bind this function to the key `F9', however we
     would like this binding to be in effect only when we are within
     `texinfo-mode'. To do that, first we must define a hook function
     that establishes the local bindings using `define-key':
          (defun texinfo-elef-hook ()
            (define-key texinfo-mode-map [F9] 'texi-insert-@example))

     The syntax of `define-key' is similar to `global-set-key' except
     it takes the name of the local keymap as an additional argument.
     The local keymap of any `NAME-mode' is `NAME-mode-map'. Finally,
     we must ask `texinfo-mode' to call the function
     `texinfo-elef-hook'. To do that use the `add-hook' command:
          (add-hook 'texinfo-mode-hook 'texinfo-elef-hook)

     In some cases, Emacs itself will provide you with a few optional
     hooks that you can attach to your modes.

  5. You can write your own modes! If you write a program whose use
     involves editing some type of input files, it is very much
     appreciated by the community if you also write an Emacs mode for
     thet file and distribute it with your program.

   With the exception of simple customizations, most of the more
complicated ones require that you write new Emacs Lisp functions,
distribute them with your software and somehow make them visible to the
installer's Emacs when person installs your software.  *Note Emacs Lisp
with Automake::, for more details on how to include Emacs Lisp packages
to your software.

   Here are some simple customizations that you might want to add to
your `.emacs' file:

   * Set your default background and foreground color for all your
     Emacs frames:
          (set-background-color "black")
          (set-foreground-color "white")

     You can change the colors to your liking.

   * Tell Emacs your name and your email address. This is particularly
     useful when you work on an off-line home system but you want Emacs
     to use the email address of your internet provider, and your real
     name. Specifying your real name is necessary if you call yourself
     "Skeletor" or "Dude" on your home computer.
          (setq user-mail-address "karl@whitehouse.com")
          (setq user-full-name "President Karl Marx")

     Make sure the name is your real name, and the email address that
     you include can receive email 24 hours per day.

   * Add a few toys to the status bar. These commands tell Emacs to
     display a clock, and the line and column number of your cursor's
     position at all times.
          (display-time)
          (line-number-mode 1)
          (column-number-mode 1)

   * When you use the mouse to cut and paste text with Emacs, mouse
     button 1 will select text and mouse button 2 will paste it.
     Unfortunately, when you click mouse button 2, emacs will first
     move the cursor at the location of the mouse, and then insert the
     text in that location.  If you are used to editing with vi under
     xterms, you will instead prefer to position the cursor yourself,
     and use mouse button 2 to simply cause the text to be pasted
     without changing the position of the cursor. If you prefer this
     behaviour, then add the following line to your `.emacs':
          (global-set-key [mouse-2] 'yank)
     By default, selected text in Emacs buffers is highlighted with
     blue color.  However, you can also select and paste into an Emacs
     buffer text that you select from other applications, like your web
     browser, or your xterm.

   * Use "font-lock". Font-lock decorates your editted text with colors
     that make it easier to read text with complicated syntax, such as
     software source codes. This is one of the coolest features of
     Emacs. To use it, add the following lines to your `.emacs':
          (global-font-lock-mode t)
          (setq font-lock-maximum-size nil)

   * To get rid of the scrollbar at the left of your Emacs window, type
          (setq scroll-bar-mode nil)

     The only reason that the scrollbar is default is to make Emacs
     more similar to what lusers are used to. It is assumed that
     seasoned hacker, who will be glad to see the scrollbar bite it,
     will figure out how to make it go away.

   * With most versions of Emacs, you should add the following to your
     `.emacs' to make sure that editing `configure.in' takes you to
     `m4-mode' and editing `Makefile.am' takes you to `makefile-mode'.
          (setq auto-mode-alist
            (append '(
              ("configure.in" . m4-mode)
              ("\\.m4\\'" . m4-mode)
              ("\\.am\\'" . makefile-mode))
             auto-mode-alist))

     You will have to edit such files if you use the GNU build system.
     *Note The GNU build system::, for more details.

   * If you have installed Emacs packages in non-standard directories,
     you need to add them to the `load-path' variable. For example,
     here's how to add a couple of directories:
          (setq load-path
                (append "/usr/share/emacs/site-lisp"
                        "/usr/local/share/emacs/site-site"
                        (expand-file-name "~lf/lisp")
                        load-path))

     Note the use of `expand-file-name' for dealing with non-absolute
     directories. If you are a user in an account where you don't have
     root priviledge, you are very likely to need to install your Emacs
     packages in a non-standard directory.

   * *Note Using vi emulation::, if you would like to customize Emacs
     to run a vi editor under the Emacs system.

   * *Note Navigating source code::, for more details on how to
     customize Emacs to make navigating a source code directory tree
     easier.

   * *Note Using Emacs as an email client::, if you would like to set
     up Emacs to process your email.

   * Autotools distributes two Emacs packages. One for handling
     copyright notices, and another one for handling Texinfo
     documentation.  *Note Inserting copyright notices with Emacs::, and
     *Note GNU Emacs support for Texinfo::, for more details.
   Emacs now has a graphical user interface to customization that will
write `.emacs' for you automatically. To use it, select:
     Help ==> Customize ==> Browse Customization Groups

from the menu bar. You can also manipulate some common settings from:
     Help ==> Options


File: toolsmanual.info,  Node: Using vi emulation,  Next: Navigating source code,  Prev: Configuring GNU Emacs,  Up: Using GNU Emacs

Using vi emulation
==================

   Many hackers prefer to use the `vi' editor. The `vi' editor is the
standard editor on Unix. It is also always available on GNU/Linux.
Many system administrators find it necessary to use vi, especially when
they are in the middle of setting up a system in which Emacs has not
been installed yet. Besides that, there are many compelling reasons why
people like vi.
   * Vi requires only two special keys: the <SHIFT> key and the <ESC>
     key. All the other keys that you need are standard on all
     keyboards.  You do not need <CTRL>,<ALT>,the cursor keys or any of
     the function keys. Some terminals that miss the escape key,
     usually have the control key and you can get escape with:
     `<CTRL>-['

   * Vi was designed to deal with terminals that connect to mainframes
     over a very slow line. So it has been optimized to allow you to do
     the most editing possible with the fewest keystrokes. This allows
     users to edit text very efficiently.

   * Vi allows your fingers to stay at the center of the keyboard, with
     the occasional hop to the escape key. It does not require you to
     stretch your fingers in funny control combinations, which makes
     typing less tiring and more comfortable.
   Because most rearrangements of finger habits are not as optimal as
the vi finger habits, most vi users react very unpleasently to other
editors.  For the benefit of these users, in this section we describe
how to run a vi editor under the Emacs system. Similarly, users of
other editors find the vi finger habits strange and unintuitive. For
the benefit of these users we describe briefly how to use the vi
editor, so they can try it out if they like.

   The vi emulation package for the Emacs system is called "Viper".  To
use Viper, add the following lines in your `.emacs':
     (setq viper-mode t)
     (setq viper-inhibit-startup-message 't)
     (setq viper-expert-level '3)
     (require 'viper)

We recommend expert level 3, as the most balanced blend of the vi
editor with the Emacs system. Most editing modes are aware of Viper,
and when you begin editing the text you are immediately thrown into
Viper. Some modes however do not do that. In some modes, like the Dired
mode, this is very appropriate. In other modes however, especially
custom modes that you have added to your system, Viper does not know
about them, so it does not configure them to enter Viper mode by
default. To tell a mode to enter Viper by default, add a line like the
following to your `.emacs' file:
     (add-hook 'm4-mode-hook 'viper-mode)

The modes that you are most likely to use during software development
are
     c-mode  , c++-mode , texinfo-mode
     sh-mode , m4-mode  , makefile-mode

Sometimes, Emacs will enter Viper mode by default in modes where you
prefer to get Emacs modes. In some versions of Emacs, the
`compilation-mode' is such a mode. To tell a mode *not* to enter Viper
by default, add a line like the following to your `.emacs' file:
     (add-hook 'compilation-mode-hook 'viper-change-state-to-emacs)

The Emacs distribution has a Viper manual. For more details on setting
Viper up, you should read that manual.

   The vi editor has these things called _editing modes_. An editing
mode defines how the editor responds to your keystrokes. Vi has three
editing modes: "insert mode", "replace mode" and "command mode".  If
you run Viper, there is also the Emacs mode. Emacs indicates which mode
you are in by showing one of `<I>', `<R>', `<V>', `<E>' on the statusbar
correspondingly for the Insert, Replace, Command and Emacs modes.
Emacs also shows you the mode by the color of the cursor. This makes it
easy for you to keep track of which mode you are in.
   * "Insert mode": When you are in insert mode, the editor simply
     "inserts" the things that you type into the text that is being
     editted. If there are any characters in front of your cursor,
     these characters are pushed ahead and they are not overwritten.
     Under Viper, when you are in insert mode, the color of your cursor
     is green. The only key that has special meaning, while you are in
     insert mode is <ESC>. If you press the escape key, you are taken
     to "command mode".

   * "Replace mode": When you are in replace mode, the editor replaces
     the text under the cursor with the text that is being typed. So,
     you want insert mode when you want to write over what's already
     written. Under Viper, when you are in replace mode, the color of
     your cursor is red. The <ESC> will take you to "command mode."

   * "Command mode": When you are in command mode, every letter key
     that you press is a command and has a special meaning. Some of
     these keys allow you to navigate the text. Other keys allow you to
     enter either insert or replace mode.  And other keys do various
     special things. Under Viper, when you are in command mode, the
     color of your cursor is white.

   * "Emacs mode": When you are in Emacs mode, then Viper is turned off
     on the specific buffer, and Emacs behaves as the default Emacs
     editor.  You can switch between Emacs mode and Command mode by
     pressing `<CTRL>-z'. So to go to Emacs mode, from Insert of
     Replace mode, you need to go through Command mode. When you are
     dealing with a buffer that runs a special editing mode, like Dired,
     Emacs defines a specialized "command mode" for manipulating that
     buffer, that can be completely different from the canonical Viper
     command mode.  You want to be in that mode to access the intended
     functionality. Occasionally however, you may like to hop to
     viper's command mode to navigate the buffer, do a search or save
     the buffer's contents. When you hop to one of the other three
     modes, the buffer will suddendly be just text to your editor.
   While you are in Command mode, you can prepend keystrokes with a
number.  Then the subsequent keystroke will be executed as many times
as the number.  We now list the most important keystrokes that are
available to you, while you are in Viper's command mode:
   * The following keystrokes allow you to navigate the cursor around
     your text without making any changes on the text itself
    `h'
          moves one character to the left

    `j'
          moves down one line

    `k'
          moves up one line

    `l'
          moves one character to the left

    `w'
          moves forward one word

    `5w'
          moves forward five words (get the idea?)

    `b'
          moves back one word

    `0'
          moves to the beginning of the current line

    `$'
          moves to the end of the current line

    `G'
          moves to the last line in the file

    `1G'
          moves to the first line in the file

    `:10'
          moves to line 10 in the file (get the idea?)

    `{'
          moves up one paragraph

    `}'
          moves down one paragraph

   * The following keystrokes allow you to delete text
    `x'
          Deletes the character under the cursor

    `dd'
          Deletes the current line

    `4dd'
          Deletes four lines

    `dw'
          Deletes the current word

    `8dw'
          Deletes the next eight words

   * The following keystrokes allow you to enter Insert mode
    `a'
          Append text after the cursor position

    `i'
          Insert text at the current cursor position

    `o'
          Insert text on a new line bellow the current line

    `O'
          Insert text on a new line above the current line

   * The following keystrokes allow you to enter Replace mode.
    `R'
          Replace text at the cursor position and stay in Replace mode.

    `s'
          Replace (substitute) only the character at the cursor
          position, and enter Insert mode for all subsequent characters.

   * The following commands handle file input/output. All of these
     commands are prepended by the `:' character. The `:' character is
     used for commands that require many characters to be properly
     expressed.  The full text of these commands is entered in the
     minibuffer. Under viper, the minibuffer itself can run under
     insert, replace and command mode.  By default you get insert mode,
     but you can switch to command mode by pressing <ESC>.
    `:w'
          Save the file to the disk

    `:w!'
          Force the file to be saved to disk even when file permissions
          do not allow it but you have the power to overrule the
          permissions.

    `:w FILENAME <RET>'
          Save the file to the disk under a specific filename.  When
          you press <SPACE> Emacs inserts the full pathname of the
          current directory for you, which you can edit if you like.

    `:w! FILENAME <RET>'
          Force the file to be saved to the disk under a specific
          filename.

    `:r FILENAME <RET>'
          Paste a file from the disk at the cursor's current position.

    `:W'
          Save all the files on all the Emacs buffers that correspond
          to open files.

    `:q'
          Kill the buffer. This does not quite the editor at expert
          level 3.

    `:q!'
          Kill the buffer even if the contents are not saved. Use with
          caution!

   * The following commands handle search and replace
    `/STRING <RET>'
          Search for STRING.

    `n'
          Go to the next occurance of STRING.

    `N'
          Go to the previous occurance of STRING.

    `:%s/STRING1/STRING2/g <RET>'
          Replace all occurances of STRING1 with STRING2.  Use this
          with extreme caution!

   * The following commands handle "undo"
    `u'
          Undo the previous change. Press again to undo the undo

    `.'
          Press this if you want to repeat the undo further.
   These are enough to get you started. Getting used to dealing with
the modes and learning the commands is a matter of building finger
habits. It may take you a week or two before you become comfortable
with Viper. When Viper becomes second nature to you however, you won't
want to tolerate what you used to use before.


File: toolsmanual.info,  Node: Navigating source code,  Next: Using Emacs as an email client,  Prev: Using vi emulation,  Up: Using GNU Emacs

Navigating source code
======================

   When you develop software, you need to edit many files at the same
time, and you need an efficient way to switch from one file to another.
The most general solution in Emacs is by going through "Dired", the
Emacs Directory Editor.

   To use Dired effectively, we recommend that you add the following
customizations to your `.emacs' file: First, add
     (add-hook 'dired-load-hook (function (lambda () (load "dired-x"))))
     (setq dired-omit-files-p t)

to activate the extended features of "Dired".  Then add the following
key-bindings to the global keymap:
     (global-set-key [f1] 'dired)
     (global-set-key [f2] 'dired-omit-toggle)
     (global-set-key [f3] 'shell)
     (global-set-key [f4] 'find-file)
     (global-set-key [f5] 'compile)
     (global-set-key [f6] 'visit-tags-table)
     (global-set-key [f8] 'add-change-log-entry-other-window)
     (global-set-key [f12] 'make-frame)

If you use viper (*note Using vi emulation::), you should also add the
following customization to your `.emacs':
     (add-hook 'compilation-mode-hook 'viper-change-state-to-emacs)

With these bindings, you can navigate from file to file or switch
between editing and the shell simply by pressing the right function
keys.  Here's what these key bindings do:
`f1'
     Enter the directory editor.

`f2'
     Toggle the omission of boring files.

`f3'
     Get a shell at the current Emacs window.

`f4'
     Jump to a file, by filename.

`f5'
     Run a compilation job.

`f6'
     Load a `TAGS' file.

`f8'
     Update the `ChangeLog' file.

`f12'
     Make a new frame.

When you first start Emacs, you should create a few frames with `f12'
and move them around on your screen. Then press `f1' to enter the
directory editor and begin navigating the file system. To select a file
for editing, move the cursor over the filename and press enter.  You
can select the same file from more than one emacs window, and edit
different parts of it in every different window, or use the mouse to
cut and paste text from one part of the file to another.  If you want
to take a direct jump to a specific file, and you know the filename of
that file, it may be faster to press `f4' and enter the filename rather
than navigate your way there through the directory editor.

   To go down a directory, move the cursor over the directory filename
and press enter. To go up a few directories, press `f1' and when you
are prompted for the new directory, with the current directory as the
default choice, erase your way up the hierarchy and press <RET>.  To
take a jump to a substantially different directort that you have
visited recently, press `f1' and then when prompted for the destination
directory name, use the cursor keys to select the directory that you
want among the list of directories that you have recently visited.

   While in the directory navigator, you can use the cursor keys to move
to another file. Pressing <<RET>> will bring that file up for editing.
However there are many other things that Dired will let you do instead:
`Z'
     Compress the file. If already compressed, uncompress it.

`L'
     Parse the file through the Emacs Lisp interpreter. Use this only
     on files that contain Emacs Lisp code.

`I, N'
     Visit the current file as an Info file, or as a "man page".  *Note
     Browsing documentation::.

`d'
     Mark the file for deletion

`u'
     Remove a mark on the file for deletion

`x'
     Delete all the files marked for deletion

`C DESTINATION <RET>'
     Copy the file to DESTINATION.

`R FILENAME <RET>'
     Rename the file to FILENAME.

`+ DIRECTORYNAME <RET>'
     Create a directory with name DIRECTORYNAME.

Dired has many other features. See the `GNU Emacs User Manual', for
more details.

   Emacs provides another method for jumping from file to file: "tags".
Suppose that you are editing a C program whose source code is
distributed in many files, and while editing the source for the
function `foo', you note that it is calling another function `gleep'.
If you move your cursor on `gleep', then Emacs will let you jump to the
file where `gleep' is defined by pressing `M-.'. You can also jump to
other occurances in your code where `gleep' is invoked by pressing
`M-,'. In order for this to work, you need to do two things: you need
to generate a tags file, and you need to tell emacs to load the file.
If your source code is maintained with the GNU build system, you can
create that tags files by typing:
     % make tags

from the top-level directory of your source tree. Then load the tags
file in Emacs by navigating Dired to the toplevel directory of your
source code, and pressing `f6'.

   While editing a file, you may want to hop to the shell prompt to run
a program. You can do that at any time, on any frame, by pressing `f3'.
To get out of the shell, and back into the file that you were editing,
enter the directory editor by pressing `f1', and then press `<RET>'
repeatedly. The default selections will take you back to the file that
you were most recently editing on that frame.

   One very nice feature of Emacs is that it understands tar files.  If
you have a tar file `foo.tar' and you select it under Dired, then Emacs
will load the entire file, parse it, and let you edit the individual
files that it includes directly. This only works, however, when the tar
file is not compressed. Usually tar files are distributed compressed,
so you should uncompress them first with `Z' before entering them.
Also, be careful not to load an extremely huge tar file.  Emacs may
mean "eating memory and constantly swaping" to some people, but don't
push it!

   Another very powerful feature of Emacs is the Ange-FTP package: it
allows you to edit files on other computers, remotely, over an FTP
connection.  From a user perspective, remote files behave just like
local files.  All you have to do is press `f1' or `f4' and request a
directory or file with filename following this form:
     /USERNAME@HOST:/PATHNAME

Then Emacs will access for you the file `/PATHNAME' on the remote
machine HOST by logging in over FTP as USERNAME.  You will be prompted
for a password, but that will happen only once per host. Emacs will then
download the file that you want to edit and let you make your changes
locally.  When you save your changes, Emacs will use an FTP connection
again to upload the new version back to the remote machine, replacing
the older version of the file there. When you develop software on a
remote computer, this feature can be very useful, especially if your
connection to the Net is over a slow modem line. This way you can edit
remote files just like you do with local files. You will still have to
telnet to the remote computer to get a shell prompt. In Emacs, you can
do this with `M-x telnet'.  An advantage to telneting under Emacs is
that it records your session, and you can save it to a file to browse
it later.

   While you are making changes to your files, you should also be
keeping a diary of these changes in a `ChangeLog' file (*note
Maintaining the documentation files::). Whenever you are done with a
modification that you would like to log, press `f8', _while the cursor
is still at the same file_, and preferably near the modification (for
example, if you are editing a C program, be inside the same C
function). Emacs will split the frame to two windows. The new window
brings up your `ChangeLog' file.  Record your changes and click on the
status bar that separates the two windows with the 2nd mouse button to
get rid of the `ChangeLog' file.  Because updating the log is a
frequent chore, this Emacs help is invaluable.

   If you would like to compile your program, you can use the shell
prompt to run `make'. However, the Emacs way is to use the `M-x compile'
command. Press `f5'. Emacs will prompt you for the command that you
would like to run. You can enter something like: `configure', `make',
`make dvi', and so on (*note Installing a GNU package::). The directory
on which this command will run is the current directory of the current
buffer. If your current buffer is visiting a file, then your command
will run on the same directory as the file. If your current buffer is
the directory editor, then your command will run on that directory.
When you press `<RET>', Emacs will split the frame into another window,
and it will show you the command's output on that window. If there are
error messages, then Emacs converts these messages to hyperlinks and
you can follow them by pressing `<RET>' while the cursor is on them, or
by clicking on them with the 2nd mouse button.  When you are done,
click on the status bar with the 2nd mouse button to get the
compilation window off your screen.


File: toolsmanual.info,  Node: Using Emacs as an email client,  Next: Handling patches,  Prev: Navigating source code,  Up: Using GNU Emacs

Using Emacs as an email client
==============================

   You can use Emacs to read your email. If you maintain free software,
or in general maintain a very active internet life, you will get a lot
of email. The Emacs mail readers have been designed to address the needs
of software developers who get endless tons of email every day.

   Emacs has two email programs: Rmail and Gnus. Rmail is simpler to
learn, and it is similar to many other mail readers. The philosophy
behind Rmail is that instead of separating messages to different
folders, you attach "labels" to each message but leave the messages on
the same folder.  Then you can tell Rmail to browse only messages that
have specific labels.  Gnus, on the other hand, has a rather eccentric
approach to email. It is a news-reader, so it makes your email look
like another newsgroup!  This is actually very nice if you are
subscribed to many mailing lists and want to sort your email messages
automatically. To learn more about Gnus, read the excellent Gnus
manual. In this manual, we will only describe Rmail.

   When you start Rmail, it moves any new mail from your mailboxes to
the file `~/RMAIL' in your home directory. So, the first thing you need
to tell Rmail is where your mailboxes are.  To do that, add the
following to your `.emacs':
     (require 'rmail)
     (setq rmail-primary-inbox-list
           (list "MAILBOX1" "MAILBOX2" ...))

If your mailboxes are on a filesystem that is mounted to your computer,
then you just have to list the corresponding filenames.  If your mailbox
is on a remote computer, then you have to use the POP protocol to
download it to your own computer. In order for this to work, the remote
computer must support POP. Many hobbyist developers receive their email
on an internet provider computer that is connected to the network 24/7
and download it on their personal computer whenever they dial up.

   For example, if `karl@whitehouse.gov' is your email address at your
internet provider, and they support POP, you would have to add the
following to your `.emacs':
     (require 'rmail)
     (setq rmail-primary-inbox-list
           (list "po:karl"))
     (setenv "MAILHOST" "whitehouse.gov")
     (setq rmail-pop-password-required t)
     (setq user-mail-address "karl@whitehouse.gov")
     (setq user-full-name "President Karl Marx")

The string `"po:USERNAME"' is used to tell the POP daemon which mailbox
you want to download. The environment variable `MAILHOST' tells Emacs
which machine to connect to, to talk with a POP daemon.  We also tell
Emacs to prompt in the minibuffer to request the password for logging
in with the POP daemon. The alternative is to hardcode the password
into the `.emacs' file, but doing so is not a very good idea: if the
security of your home computer is compromised, the cracker also gets
your password for another system. Emacs will remember the password
however, after the first time you enter it, so you won't have to enter
it again later, during the same Emacs session. Finally, we tell Emacs
our internet provider's email address and our "real name" in the
internet provider's account. This way, when you send email from your
home computer, Emacs will spoof it to make it look like it was sent
from the internet provider's computer.

   In addition to telling Rmail where to find your email, you may also
want to add the following configuration options:
  1. Quote messages that you respond to with the `>' prefix:
          (setq mail-yank-prefix ">")

  2. Send yourself a blind copy of every message
          (setq mail-self-blind t)

  3. Alternatively, archive all your outgoing messages to a separate
     file:
          (setq mail-archive-file-name "/home/USERNAME/mail/sent-mail")

  4. To have Rmail insert your signature in every message that you send:
          (setq mail-signature t)

     and add the actual contents of your signature to `.signature' at
     your home directory.

   Once Rmail is configured, to start downloading your email, run `M-x
rmail' in Emacs. Emacs will load your mail, prompt you for your POP
password if necessary, and download your email from the internet
provider. Then, Emacs will display the first new message. You may
quickly navigate by pressing `n' to go to the next message or `p' to go
to the previous message.  It is much better however to tell Emacs to
compile a summary of your messages and let you to navigate your mailbox
using the summary. To do that, press `h'. Emacs will split your frame
to two windows: one window will display the current message, and the
other window the summary. A highlighted bar in the summary indicates
what the current message is. Emacs will also display any labels that
you have associated with your messages.  While the current buffer is
the summary, you can navigate from message to message with the cursor
keys (`up' and `down' in particular).  You can also run any of the
following commands:
`h'
     display a summary of all the messages

`s'
     save any changes made to the mail box

`<'
     go to the first message in the summary

`>'
     go to the last message in the summary

`g'
     download any new email

`r'
     reply to a message

`f'
     forward a message

`m'
     compose a new message

`d'
     delete the current message

`u'
     undelete the current message

`x'
     expunge messages marked for deletion

`a LABEL <RET>'
     add the label LABEL to the current message

`k LABEL <RET>'
     remove the label LABEL from the current message

`l LABEL <RET>'
     display a summary only of the messages with label LABEL

`o FOLDER <RET>'
     add the current message to another folder

`w FILENAME <RET>'
     write the body of the current message to a file

Other than browing email, here is some things that you will want to do:
   * *Compose a message*: To compose a message press `m'. Emacs will
     take you to a new buffer where you can write the actual contents
     of your message. Emacs separates this buffer with a line that says:
          --text follows this line--

     Before this line you may edit the message's headers. After this
     line, you edit the actual body of the of the message.  When you
     are done composing the message, you can do one of the following:
    `C-c C-w'
          Insert the signature

    `C-c C-y'
          Quote (yank) the current message

    `C-c C-c'
          Send the message

    `Mail ==> Cancel'
          Cancel the message These commands are also available when you
     reply to or forward email messages.

   * *Reply to a message*: To reply to a message press `r'.  Emacs will
     do the same thing that it does when you ask it to compose a
     message. The only difference is that it writes the headers of the
     message for you automatically such that the response is sent to
     all the people that have received the original message. You may
     edit the headers to add or remove recipient email addresses.
     Emacs will not quote the message that you respond to by default.
     To quote it use `C-c C-y'.

   * *Forward a message*: To forward a message press `f'.  Emacs will
     write the headers for you and it will also quote the message that
     you are forwarding, however it will not prefix it with `>' (or
     whatever character you use to prefix messages that you reply to).
     The quoted message is clearly delimited with markers that indicate
     that it is the forwarded message. You can add commentary,
     preferably, before the markers so that the recipient can see it
     before seeing the forwarded message.
   In every one of these three cases you may need to edit the message's
headers.  The most commonly used header entries that Emacs recognizes
are:
`To:'
     list address of the recipient to whom the message is directed

`Cc:'
     list addresses of other recipients that need to recieve courtesy
     copies of the message

`BCC:'
     list addresses of other recipients to send a copy to, without
     showing their email address on the actual message

`FCC:'
     list folders (filenames) where you would like the outgoing message
     to be appended to

`Subject:'
     the subject field for the message The fields `To:', `CC:', `BCC:'
and `FCC:' can also have continuation lines: any subsequent lines that
begin with a space are considered part of the field.


File: toolsmanual.info,  Node: Handling patches,  Next: Inserting copyright notices with Emacs,  Prev: Using Emacs as an email client,  Up: Using GNU Emacs

Handling patches
================

   _Believe it or not, I really don't know how to do that. I need a
volunteer to explain this to me so I can explain it then in this
section_


File: toolsmanual.info,  Node: Inserting copyright notices with Emacs,  Next: Hacker sanity with Emacs,  Prev: Handling patches,  Up: Using GNU Emacs

Inserting copyright notices with Emacs
======================================

   When you develop free software, you must place copyright notices at
every file that invokes the General Public License. If you don't place
any notice whatsoever, then the legal meaning is that you refuse to
give any permissions whatsoever, and the software consequently is not
free. For more details see *Note Applying the GPL::.  Many hackers, who
don't take the law seriously, complain that adding the copyright
notices takes too much typing. Some of these people live in countries
where copyright is not really enforced. Others simply ignore it.

   There is an Emacs package, called `gpl', which is currently
distributed with Autotools, that makes it possible to insert and
maintain copyright notices with minimal work. To use this package, in
your `.emacs' you must declare your identity by adding the following
commands:
     (setq user-mail-address "me@here.com")
     (setq user-full-name "My Name")

Then you must require the packages to be loaded:
     (require 'gpl)
     (require 'gpl-copying)

This package introduces the following commands:
`gpl'
     Insert the standard GPL copyright notice using appropriate
     commenting.

`gpl-fsf'
     Toggle FSF mode. Causes the `gpl' command to insert a GPL notice
     for software that is assigned to the Free Software Foundation.
     The `gpl' command autodetects what type of file you are editing,
     from the filename, and uses the appropriate commenting.

`gpl-personal'
     Toggle personal mode. Causes the `gpl' command to insert a GPL
     notice for software in which you keep the copyright.  If you are
routinely assigning your software to an organization other than the
Free Software Foundation, then insert:
     (setq gpl-organization "NAME")

after the `require' statements in your `.emacs'.


File: toolsmanual.info,  Node: Hacker sanity with Emacs,  Next: Further reading on Emacs,  Prev: Inserting copyright notices with Emacs,  Up: Using GNU Emacs

Hacker sanity with Emacs
========================

   Every once in a while, after long heroic efforts in front of the
computer monitor, a software developer will need to some counseling to
feel better about perself. In RL (real life) counseling is very
expensive and it also involves getting up from your computer and
transporting yourself to another location, which descreases your
productivity. Emacs can help you.  Run `M-x doctor', and you will talk
to a psychiatrist for free.

   Many people say that hackers work too hard and they should go out for
a walk once in a while. In Emacs, it is possible to do that without
getting up from your chair. To enter an alternate universe, run `M-x
dunnet'. Aside from being a refreshing experience, it is also a very
effective way to procrastinate away work that you don't want to do.
Why do today, what you can postpone for tomorrow?


File: toolsmanual.info,  Node: Further reading on Emacs,  Prev: Hacker sanity with Emacs,  Up: Using GNU Emacs

Further reading on Emacs
========================

   This chapter should be enough to get you going with GNU Emacs. This
is really all you need to know to use Emacs to develop software.
However, the more you learn about Emacs, the more effectively you will
be able to use it, and there is still a lot to learn; a lot more than
we can fit in this one chapter. In this section we refer to other
manuals that you can read to learn more about Emacs. Unlike many
proprietary manuals that you are likely to find in bookstores, these
manuals are _free_ (*note Why free software needs free documentation::).
Whenever possible, please contribute to the GNU project by ordering a
bound copy of the free documentation from the Free Software Foundation,
or by contributing a donation.

   The Free Software Foundation publishes the following manuals on
Emacs:
`The Emacs Editor'
     This manual tells you all there is to know about all the spiffy
     things that Emacs can do, except for a few things here and there
     that are so spiffy that they get to have their own separate
     manual. The printed version, published by the Free Software
     Foundation, features our hero, Richard Stallman, riding a gnu. It
     also includes the GNU Manifesto.  The machine readable source for
     the manual is distributed with GNU Emacs.

`Programming in Emacs Lisp'
     A wonderful introduction to Emacs Lisp, written by Robert Chassell.
     If you want to learn programming in Emacs Lisp, start by reading
     this manual.  You can order this manual as a bound book from the
     Free Software Foundation.  You can also download a machine
     readable copy of the manual from any GNU ftp site. Look for
     `elisp-manual-20-2.5.tar.gz'.

`The GNU Emacs Lisp Reference Manual'
     This is a comprehensive reference manual for the Emacs Lisp
     language.  You can also order this manual as a bound book from the
     Free Software Foundation.  You can also download a machine
     readable copy of the manual from any GNU ftp site. Look for
     `emacs-lisp-intro-1.05.tar.gz'.

The following manuals are also distributed with the GNU Emacs source
code and they make for some very fun reading:
`Gnus Manual'
     Gnus is the Emacs newsreader. You can also use it to sort out your
     email, especially if you are subscribed to twenty mailing lists
     and receive tons of email every day. This manual will tell you all
     you need to know about Gnus to use it effectively. (`gnus.dvi')

`CC Mode'
     The Emacs C editing mode will help you write C code that is
     beautifully formatted and consistent with the GNU coding
     standards. If you develop software for an organization that
     follows different coding standards, you will have to customize
     Emacs to use their standards instead. If they are lame and haven't
     given you Elisp code for their standards, then this manual will
     show you how to roll your own. (`cc-mode.dvi')

`Common Lisp Extensions'
     Emacs has a package that introduces many Common Lisp extensions to
     Emacs Lisp.  This manual describes what extensions are available
     and how to use them.  (`cl.dvi')

`Writing Customization Definitions'
     Recent versions of Emacs have an elaborate user-friendly
     customization interface that will let users customize Emacs and
     update their `.emacs' files automatically for them. If you are
     writing large Emacs packages, it is very easy to add a
     customization interface to them.  This manual explains how to do
     it.  (`customize.dvi')

`The Emacs Widget Library'
     It is possible to insert actual widgets in an Emacs buffer that are
     bound to Emacs Lisp functions. This feature of Emacs is used, for
     example, in the newly introduced customization interface. This
     manual documents the Elisp API for using these widgets in your own
     Elisp packages.  (`widget.dvi')

`RefTeX User Manual'
     If you are writing large documents with LaTeX that contain a lot of
     crossreferences, then the RefTeX package will make your life
     easier.  (`reftex.dvi')

`Ediff User's Manual'
     Ediff is a comprehensive package for dealing with patches under
     Emacs.  If you receive a lot of patches to your software projects
     from contributors, you can use Ediff to apply them to your source
     code.  (`ediff.dvi')

`Supercite User's Manual'
     If you think that quoting your responses to email messages with
     `>' is for lamers and you want to be elite, then use Supercite.
     (`sc.dvi')

`Viper Is a Package for Emacs Rebels'
     This manual has more than you will ever need to know about Viper,
     the Emacs vi emulation. *Note Using vi emulation::, actually
     describes all the features of Viper that you will ever really
     need. But still, it's a good reading for a long airplane trip.
     (`viper.dvi')


File: toolsmanual.info,  Node: Compiling with Makefiles,  Next: The GNU build system,  Prev: Using GNU Emacs,  Up: Top

Compiling with Makefiles
************************

   In this chapter we describe how to use the compiler to compile
simple software and libraries, and how to use makefiles.

* Menu:

* Compiling simple programs::
* Programs with many source files::
* Building libraries::
* Dealing with header files::
* The GPL and libraries::
* The language runtime libraries::
* Basic Makefile concepts::
* More about Makefiles::


File: toolsmanual.info,  Node: Compiling simple programs,  Next: Programs with many source files,  Prev: Compiling with Makefiles,  Up: Compiling with Makefiles

Compiling simple programs
=========================

   It is very easy to compile simple C programs on the GNU system. For
example, consider the famous "Hello world" program:
`hello.c'
          #include <stdio.h>
          int
          main ()
          {
            printf ("Hello world\n");
          }

The simplest way to compile this program is to type:
     % gcc hello.c

on your shell. The resulting executable file is called `a.out' and you
can run it from the shell like this:
     % ./a.out
     Hello world

To cause the executable to be stored under a different filename pass the
`-o' flag to the compiler:
     % gcc hello.c -o hello
     % ./hello
     Hello world

Even with simple one-file hacks like this, the GNU compiler can accept
many options that modify its behaviour:
`-g'
     The `-g' flag causes the compiler to output debugging information
     to the executable. This way, you can step your program through a
     debugger if it crashes.  (_FIXME: Crossreference_)

`-O, -O2, -O3'
     The `-O', `-O2', `-O3' flags activate "optimization".  The numbers
     are called "optimization levels".   When you compile your program
     with optimization enabled, the compiler applies certain algorithms
     to the machine code output to make it go faster. The cost is that
     your program compiles much more slowly and that although you can
     step it through a debugger if you used the `-g' flag, things will
     be a little strange. During development the programmer usually
     uses no optimization, and only activates it when person is about to
     run the program for a production run. A good advice: always test
     your code with optimization activated as well.  If optimization
     breaks your code, then this is telling you that you have a memory
     bug. Good luck finding it.

`-Wall'
     The `-Wall' flag tells the compiler to issue warnings when it sees
     bad programming style. Some of these warning catch actual bugs, but
     occasionally some of the warnings complain about something correct
     that you did on purpose. For this reason this flag is feature is
     not activated by default.

Here are some variations of the above example:
     % gcc -g -O3 hello.c hello
     % gcc -g -Wall hello.c -o hello
     % gcc -g -Wall -O3 hello.c -o hello

To run a compiled executable in the current directory just type its
name, prepended by `./'. In general, once you compile a useful program,
you should "install" it so that it can be run from any current
directory, simply by typing its name without prepending `./'.  To
install an executable, you need to move it to a standard directory such
as `/usr/bin' or `/usr/local/bin'. If you don't have permissions to
install files there, you can instead install them on your home
directory at `/home/username/bin' where `username' is your username.
When you write the name of an executable, the shell looks for the
executable in a set of directories listed in the environment variable
`PATH'. To add a nonstandard directory to your path do
     % export PATH="$PATH:/home/username/bin"

if you are using the Bash shell, or
     % setenv PATH "$PATH:/home/username/bin"

if you are using a different shell.


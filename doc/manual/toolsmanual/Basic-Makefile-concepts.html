<html lang="en">
<head>
<title>Basic Makefile concepts - Developing software with GNU</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Developing software with GNU">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Compiling-with-Makefiles.html#Compiling-with-Makefiles" title="Compiling with Makefiles">
<link rel="prev" href="The-language-runtime-libraries.html#The-language-runtime-libraries" title="The language runtime libraries">
<link rel="next" href="More-about-Makefiles.html#More-about-Makefiles" title="More about Makefiles">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Basic-Makefile-concepts"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="More-about-Makefiles.html#More-about-Makefiles">More about Makefiles</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="The-language-runtime-libraries.html#The-language-runtime-libraries">The language runtime libraries</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Compiling-with-Makefiles.html#Compiling-with-Makefiles">Compiling with Makefiles</a>
<hr>
</div>

<h3 class="section">3.7 Basic Makefile concepts</h3>

<p>To build a very large program, you need an extended set of invocations
to the &lsquo;<samp><span class="samp">gcc</span></samp>&rsquo; compiler and utilities like &lsquo;<samp><span class="samp">ar</span></samp>&rsquo;, &lsquo;<samp><span class="samp">ranlib</span></samp>&rsquo;. 
As we explained (see <a href="Programs-with-many-source-files.html#Programs-with-many-source-files">Programs with many source files</a>) if you make
changes only to a few files in your source code, it is not necessary to
rebuild everything; you only need to rebuild the object files that get
to change because of your modifications and link those together with
all the other object files to form an updated executable. The &lsquo;<samp><span class="samp">make</span></samp>&rsquo;
utility was written mainly to automate rebuilding software by determining
the minimum set of commands that need to be called to do this, and invoking
them for you in the right order. It can also handle, many other
tasks. For example, you can use &lsquo;<samp><span class="samp">make</span></samp>&rsquo; to install your program's
files in the standard directories, and clean up the object files
when you no longer need them.

   <p>To learn all about &lsquo;<samp><span class="samp">make</span></samp>&rsquo; and especially &lsquo;<samp><span class="samp">GNU Make</span></samp>&rsquo;, please read
the excellent <cite>GNU Make manual</cite>. In general, to use the GNU build
system you don't need to know the most esoteric aspects of the GNU make,
because makefiles will be automatically compiled for you from higher
level descriptions. However it is important to understand the basic
aspects of &lsquo;<samp><span class="samp">make</span></samp>&rsquo; to use the GNU build system effectively. In the
following sections we will explain only these basic aspects.

   <p>The &lsquo;<samp><span class="samp">make</span></samp>&rsquo; utility reads its instructions from a file named
<samp><span class="file">Makefile</span></samp> in the current directory. &lsquo;<samp><span class="samp">make</span></samp>&rsquo; itself has no
knowledge about the syntax of the files that it works with, and it
relies on the instructions in <samp><span class="file">Makefile</span></samp> to figure out what it
needs to do. A makefile is essentially a list of <dfn>rules</dfn>. Each rule
has the form:
<pre class="example">     <span class="sc">Target</span>: <span class="sc">Dependencies</span>
     &lt;TAB&gt; <span class="sc">Command</span>
     &lt;TAB&gt; .....
     &lt;TAB&gt; .....
     <span class="sc">[Blank Line]</span>
</pre>
   <p class="noindent">The &lt;TAB&gt;s are mandatory. The blank line at the end of the rule definition
is not necessary when using GNU make but it is a good idea if you would
like backwards compatibility with Unix.
     <ul>
<li>The <dfn>target</dfn> is either the name of a file that is generated by a program
or the name of an action to carry out. Object files and executable files
are examples of files that are generated by other programs. Cleaning
up the object files is an example of an action that we might want to
carry out. Targets that correspond to an action are sometimes called
<dfn>phony targets</dfn>. 
<li>In general a <dfn>dependency</dfn> is a file that is used as input to create a
target. If a target has more than one dependencies, they must be seperated
by spaces, but they must remain on the same line. It is possible for
a target to have no dependencies. In that case, the space after the
semicolon must be left blank. It is also possible for a target, even
one that represents an action, to be a dependency for another target. 
<li>The <dfn>commands</dfn> following the target and the dependencies must be
prepended with &lt;TAB&gt;. If the target is a file, then the commands
explain how to create that file. If the target is an action, then
the commands describe the action. These commands are your usual shell
commands that you get to type in your prompt. 
</ul>
   When you invoke <samp><span class="file">make</span></samp> you must tell it which target you want to
build. If you don't specify a target, then <samp><span class="file">make</span></samp> will build the
first target that is mentioned in the makefile.

   <p>When we talk about &lsquo;<samp><span class="samp">make</span></samp>&rsquo; <dfn>building</dfn> a target, we mean that we want
&lsquo;<samp><span class="samp">make</span></samp>&rsquo; to do the following things:
     <ol type=1 start=1>
<li><dfn>Build</dfn> the dependencies. If a dependency is a file written by
<em>you</em>, this means do nothing. If a dependency is a target defined
elsewhere in the makefile, this means <em>build that target first</em>,
which recurses this two-step process. 
<li>If at least one of the dependencies is <dfn>newer</dfn> than the target, or the
file with the name of the target does not exist, then invoke the commands
that correspond to the target. If the target is a file, then the commands
should create the file. If the target is an action, then the commands
will not create any file, but they will carry out the action.
        </ol>
Assuming that both a dependency and the
target are files, we say that the dependency is <dfn>newer</dfn> than the target,
if the dependency was last modified more recently than the target. 
The target then should be rebuild to reflect the most recent modifications
of the dependency.

   <p>If the requested target exists as a file, and there are no dependencies
newer than the target, then &lsquo;<samp><span class="samp">make</span></samp>&rsquo; will do nothing except printing
a message saying that it has nothing to do. If the requested target is
an action, no file will ever exist having the same name as the name
describing the action, so every time you ask &lsquo;<samp><span class="samp">make</span></samp>&rsquo; to build that
target, it will always carry out your request. If one of the dependencies
is a target corresponding to an action, &lsquo;<samp><span class="samp">make</span></samp>&rsquo; will always attempt
to build it and consequently always carry out that action. 
These three observations are only corollaries of the general algorithm.

   <p>To see how all this comes together in practice let's write a <samp><span class="file">Makefile</span></samp>
for compiling the hello world program. The simplest way to do this
is with the following makefile:
<pre class="example">     hello: hello.c
     &lt;TAB&gt; gcc -o hello hello.c
</pre>
   <p class="noindent">This simply says that the target <samp><span class="file">hello</span></samp> is being built from the
file <samp><span class="file">hello.c</span></samp> by invoking the <samp><span class="file">gcc</span></samp> command
<pre class="example">     % gcc -o hello hello.c
</pre>
   <p class="noindent">A more complicated way of doing the same thing is by explicitly building
the intermediate object file:
<pre class="example">     hello: hello.o
     &lt;TAB&gt; gcc -o hello hello.o
     
     hello.o: hello.c
     &lt;TAB&gt; gcc -c hello.c
</pre>
   <p class="noindent">Note that the target that we really want to build, <samp><span class="file">hello</span></samp> is listed
first, to make sure that it is the default target. 
Finally, we can add two more phony targets <code>install</code> and <code>clean</code>
to install the hello world program and clean up the build after installation. 
We get then the following:
<pre class="example">     hello: hello.o
     &lt;TAB&gt; gcc -o hello hello.o
     
     hello.o: hello.c
     &lt;TAB&gt; gcc -c hello.c
     
     clean:
     &lt;TAB&gt; rm -f hello hello.o
     
     install: hello
     &lt;TAB&gt; mkdir -p /usr/local/bin
     &lt;TAB&gt; rm -f /usr/local/bin
     &lt;TAB&gt; cp hello /usr/local/bin/hello
</pre>
   <p class="noindent">The <code>clean</code> needs no dependencies since it just does what it does. 
However, the <code>install</code> target needs to first make sure that the
file <samp><span class="file">hello</span></samp> exists before attempting to install it, so it is necessary
to list <samp><span class="file">hello</span></samp> as a dependency to <code>install</code>.

   <p>Please note that this simple <samp><span class="file">Makefile</span></samp> is for illustration only,
and it is far from ideal. For example, we use the &lsquo;<samp><span class="samp">mkdir</span></samp>&rsquo; command
to make sure that the installation directory exists before attempting
an install, but the &lsquo;<samp><span class="samp">-p</span></samp>&rsquo; flag is not portable in Unix. Also, we usually
want to use a BSD compatible version of the <samp><span class="file">install</span></samp> utility to
install executables instead of <samp><span class="file">cp</span></samp>. Fortunately, you will almost
never have to worry about writing &lsquo;<samp><span class="samp">clean</span></samp>&rsquo; and &lsquo;<samp><span class="samp">install</span></samp>&rsquo; targets,
because those will be generated for you automatically by Automake.

<!-- ============================================================ -->
   </body></html>


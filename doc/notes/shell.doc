@ignore

@chapter Portable Shell programming

@section Portable shell script syntax

A @dfn{shell script} is a file that contains shell commands, also executable
from the shell prompt, which we want to run automatically. The 
@file{configure} script generated by Autoconf is a shell script. The source
file @file{configure.in} from which it is generated contains a mix of 
shell-script source and macros. The macros
are expanded to shell-script source and/or other macros until eventually
the whole thing expands to one large executable shell script.

As a user of Autoconf you don't necessarily have to know anything about
scripting. Up until now we showed you how to operate it and use it without
saying anything detailed about it. However, to get the most out of Autoconf,
and to write new Autoconf macros you need to know how to write shell scripts.
And not just any kind of shell scripts. They have to be @emph{portable}
shell scripts! One problem with the traditional Bourn shell is that no-one
really ever wrote a grammar for it! So implementations are in many fine points
very inconsistent with one another. The GNU @code{bash} shell defines and
implements a very powerful shell and should be used for application development
when the application is best implemented as a shell script. However for
@code{configure} scripts you should not even dare to think of using
bash-specific features. Remember that it will take a @code{configure} script
to @emph{build} bash to begin with! Configure scripts must run on all 
platforms under the platform's native Bourne shell, and as such they must be 
very conservative in the amount of
features they invoke. The main reason why we choose to preprocess configure
scripts with @code{m4} is to balance out this severe limitation.

If you don't know anything about shell scripts, this
section will teach you hopefully most of what you need to know. If you already
know about shell scripts, this section will tell you what's portable.

To begin, the hello world shell script is:
  #! /bin/sh
  echo "Hello world"
Note our use of @code{/bin/sh}. This is portable. Using anything else
at all (especially @code{/bin/bash}) is not portable. It is important
to leave a space between the @code{#!} characters and @code{/bin/sh}.
It probably doesn't matter much now, but according to the lore of the
Ancient Masters, once upon a 
time there was a whacky dude that insisted that on a whacky operating
system you had to put in that space.

You can run commands very simply by writing them in sequence:
  #! /bin/sh
  command1
  command2
  command3
or you can use semicolons to seperate them:
  command1 ; command2 ; command3
or you can start a subshell and run them under it:
  (command1; command2; command3)
or
  (command1;
   command2;
   command3)
You can have the output of one command go to a file or to @file{/dev/null}
  command1 > file
  command2 > /dev/null
Note that this redirects only the standard output, not the standard error.
If you want to redirect both:
  command1 > output 2> error
You can also take input from a file while doing all of this:
  command1 < input > output 2> error
You can have the output of one command feed in as input to the second
command:
  command1 | command2
This redirects only the standard output, not the standard error. 
You can use a subshell however and capture the standard error as well:
  (command1 2> error) | command2
Another thing you can do is force the standard error to go to standard output:
  command1 2>&1
You can combine all of the above in any way you want:
  (comm1; comm2; (comm3 2> /dev/null)) | (comm4 2> /dev/null) | comm5 > output

When you write shell code specifically for an Autoconf macro you may want
to output error messages to @code{AC_FD_CC}. You should only send there
messages that have to do with the invokation of an exotic compiler.
For example various autoconf macros will test compilers to see if they 
work. If you see on the messages that your compiler doesn't work, but should,
then you would like to see what error messages it sent out. Normally these
error messages would go to standard error, and then from there to your
screen. Alternatively you may invoke:
  command 2>&AC_FD_CC
and they'll be sent to a file called @file{config.log}.
Use this only on commands who may fail and produce errors for legitimate
reasons but which errors the user might want to examine if they fail when
they shouldn't.

Commands take arguments known as command-line arguments that are seperated with
space. So a command
invokation may look like:
  command1 arg1 arg2 arg3
or
  command1 arg1 "arg2 arg3"
The difference is that in the second case @code{"arg2 arg3"} is treated
as one word, i.e. one argument. The quote mark tells the shell to suspend 
interpreting the space as an argument seperator until the next quote mark.
That fixes the space, but now ruins the quote mark. If you want to suspend
the interpretation of a quote mark as terminating quotation you have to
@emph{escape} it by preceeding it with a backslash.
  echo "arg2 \"arg3\" yeehaa"
Of course, now that ruins the meaning of the backslash. So if you want
to fix that, you can escape the backslash with another backslash:
  echo "arg2 \\ arg3"
Phew! Now you're all covered.

This use of quote marks is one form of @dfn{shell quoting}. There are
two others. For example:
  command1 `command2`
Any text that you quote within backquotes will be executed by the shell
and it's output will be substituted as one argument to @code{command1}.
When a backquote is encountered, then basically the shell rolls until
the next backquote. Then grabs all the text in between and does recursive
descent parsing on it and sends the output back up. 
For example:
  echo `pwd`
Note that backquotes are substituted even inside quotes:
  echo "This is the current directory `pwd`"
Of course you can escape backquotes with a backslash too:
  echo \`

The other substitution is shell variable substitution. A shell variable
is assigned content like this:
  variable=value
  variable="value is cool"
  variable=`pwd`
  variable=`(command1; command2; (command3 | command4); 
             whatever)`
It is also possible to put many assignments on one line:
  foo1="hello" foo2="hello there" foo3="whatever"
It is very important that there is no space before or after the equal sign.
Otherwise the shell won't know whether to interpret this as a command
invokation or a shell assignment.
Once a variable has contents, if you write @code{$variable} it will be
substituted for it's contents. For example:
  variable=`pwd`
  echo $variable
  echo "Current directory is $variable"
  (cd $variable; ls) | sort > foo
  command1 `command2 $variable`

These two substitutions, command substitution and variable substitution,
may be suspended if you quote a given text with forwardquotes.
For example:
  echo '$foo'
outputs @code{$foo}. Also other examples:
  echo "Money '$speaks$'"
  echo '`foo`'
The first forwardquotes directs the shell to suspend substitutions.
The next forwardquote directs the shell to resume. But if you just
want to use a quote as a character, then you can escape the forward
quotes too with a backslash.

When a command finishes executation it returns an exit-code. In C you
determine the exit code either by a call to
  exit(0);
or to
  exit(1);
where @code{0} means success and @code{1} means failure. You can take
advantage of exit-codes when you put together commands. For example:
  command1 && command2
will execute @code{command1} and if it is successful it will also
execute @code{command2}.
Another example:
  command1 || command2
will execute @code{command1}. If it succeeds then that's it. If it fails, then
it tries @code{command2}. Using the subshell mechanism you can do things
like:
  (command1 && command2) || command3 || (command4 && (command5 || command6))
which is quite crazy and probably useless, but there you are!

All of this is called by many people shell plumbing. 

TODO: <<END thingie!
the nm command?
what's the reason for x$foo = xfalse

@c ==========================================================================

@section Portable shell builtins

In addition to
plumbing the shell supports some structure too. The ``commands''
@code{for}, @code{if} and @code{while}, although semantically appear
as ordinary unix commands are in reality commands built-in to the shell.

@deffn Builtin for
This implements the @dfn{for-each} type of loop
  for i in 1 2 3 "4 5"
  do
    echo $i
  done
After the @code{in} you list words that are seperated by spaces (unless
quoted). Then between @code{do} and @code{done} the shell code is
executed repeatedly for each word, which is assigned, in this case,
to the shell variable @code{i}.
Sometimes you want to loop over something like the files appearing in
the output of 
  lf | grep html
but since the output spans multiple lines it is not syntactically correct 
to do
  for i in `ls | grep html`
A way to fix that is to use @code{awk}, which lines up all the words into
one line:
  for i in `ls | grep html | awk '{ printf("%s ", $1) }'`
  do
    echo "an html file $i"
  done
Another useful @code{awk} trick can enable you to do numerical looping:
  for i in `awk 'BEGIN { for (i=0; i<10; i++) printf("%s ",i) }'`
  do
    echo "Counting $i"
  done
Admittedly it's cumbersome, and under a real shell like @code{bash} there
are better ways to do it, but this works and it's portable.
Another way to get out of the loop other than the loop terminating by itself
is to invoke the @code{break} builtin. 
@end deffn

@deffn Builtin if
The syntax for a typical @code{if} statement is:
  if test-command
  then
    command1
  fi
When this is encountered, the shell executes @code{test-command} and
checks the return status. If the command returns successfully then
@code{command1} is executed. Otherwise it is ignored. 
It is possible to have an @code{else} construct like this:
  if test-command
  then
    command1
  else
    command2
  fi
If you want to do more complicated decision-making you can nest if-statements
or you can use the more appropriate @code{case} builtin.
To do the tests, there is a command @code{test} available which in reality
is a program that is executed. The @code{test} program varies from Unix
to Unix, bad the following features are portable:
@itemize @bullet
@item 
Test whether a string is empty
  test -n $string
Note that @code{-n} has to be explicitly written. In some systems you can
omit it and imply this behaviour, but doing that is not portable.
You could use this to test if a shell variable has been defined at all.
@item
Test whether a string is not empty
  test -z $string
@item
Test whether two strings are equal
  test $string1 = $string2
@item
Test whether two strings are not equal
  test $string1 != $string2
@item
Test whether a file exists
  test -f filename
@item
Test whether a file can be read
  test -r file
@item
Test whether a file can be written to
  test -w file
@end itemize
Note that the @code{-a} and @code{-o} flags (meaning @emph{and} and 
@emph{or}) are not portable and it is best instead to use the shell's
@code{&&} or @code{||} feature. For example
  if test -f file1 && test -f file2
  then
    cat file1 file2 | mail monica@whitehouse.gov
  fi
will execute only if both files exist. On the other hand
  if test $bob = $theidiot || test $bob = $themoron
  then
    cat $bob > /dev/idiotkiller
  fi
will execute only if one or both of the conditions is true.
On some shells instead of using @code{test} you can use a bracket
feature where you put the test inside brackets. But that is not portable,
and you should explicitly use @code{test} instead.
@end deffn

@deffn Builtin case
The @code{case} macro allows you to select one of many different cases.
The syntax is:
  case $foo in
  string1)
    command1
    ;;
  string2)
    command2
    ;;
  *)
    default-command
    ;;
  esac
The variable @code{foo} is compared against @code{string1}, @code{string2}
and if they are equal @code{command1} or @code{command2} are executed.
Also, in @code{string1} and friends, you can use the @code{*} as a wildcard.
For example the following will print @code{hello}.
  foo="hello"
  case $foo in
  he*o)
    echo "hello!"
    ;;
  hello)
    echo "yuck!"
    ;;
  *)
    echo "blah!"
    ;;
  esac
Note that as soon as one of these cases matches, then that's it. The 
corresponding commands will be executed and the other cases won't be 
checked. This means that if more than one cases match the string,
through wacky use of the wildcard, only the first matching case will
be executed. So in the example above, it will not print @code{yuck}.
It is possible to merge cases like this:
  case $foo in
  hello | hi | howdy)
    echo "hello to you too"
    ;;
  crap | suck | moron)
    echo "watch your language"
    ;;
  *)
    echo "huh?"
    ;;
  esac
The @code{|} character is used to seperate alternatives. You can also
use brackets to match alternatives to a character:
  case $foo in
  -[lLr])
    echo "foo is one of -l -L -r"
    ;;
  *)
    echo "howdy"
    ;;
  esac
@end deffn

@deffn Builtin while
The @code{while} builtin will make a loop run until a condition stops
being true. The syntax for @code{while} is:
  while test-command
  do
    commands
  done 
This is very similar to doing @code{if} statements. In fact you want to
use the @code{test} command here the same way you are using it in 
@code{if} statements. The @code{commands} will be executed for as long
as the condition tested by the test program in @code{test-command} is true.
If you want a loop that runs for ever then don't use @code{true} for
the @code{test-command}. Instead do this:
  while :
  do
    echo "Do you want to live for ever."
  done
To exit the loop you would need to call the @code{break} builtin at some point.
@end deffn

A note about plumbing. A structured command like an @code{if} statement
is considered one big multi-line command until the matching @code{fi}.
Similarly the @code{for} and @code{while} commands are multi-line commands
until the matching @code{done}, and @code{case} until the matching @code{esac}.
What this means is that the shell will not do absolutely anything until
it parses the entire command. To see this try typing an example interactively.
This also has implications in plumbing. Suppose that you wanted to have
the output that comes out of a for-loop piped into another program.
Then you can do it like this:
  for i in `awk 'BEGIN { for (i=0; i<10; i++) printf("%s ",i) }'`
  do
    echo "Counting $i"
  done | mail monica@whitehouse.gov

@c ===========================================================================

@section Portable shell commands for shell scripts

Now let's say something about the commands that the plumbing puts together.
You probably know many of them already:

@deffn Command echo
The @code{echo} commands just prints a message. For example:
  echo "Hello world"
It is best to not depend on special escape sequences because they are not
equally supported in all @code{echo}s. In particular never use @code{\c}
for preventing a newline. Another syntax for preventing a newline that you
should never use is:
  echo -n "Please enter your name: "
Neither is portable. In general it is very unlikely that you will have to use 
@code{echo} in Autoconf macros because as you will see, Autoconf provides
special macros for handling input and output. However Autoconf itself at
some level needs to use this feature of preventing the newline and you
may be wondering how they are doing it. First they do the following
initialization:
  if (echo "testing\c"; echo 1,2,3) | grep c >/dev/null
  then
    if (echo -n testing; echo 1,2,3) | sed s/-n/xn/ | grep xn >/dev/null
    then
      shar_n= 
      shar_c='
  '
    else
      shar_n=-n
      shar_c=
    fi
  else
    shar_n=
    shar_c='\c'
  fi
and then they invoke @code{echo} like this:
  echo $shar_n 'Any questions? ' $shar_c
This is portable on all shells. Note that if you want to echo something
that contains funny characters it may be a good idea to suspend substitutions
by quoting with forward quotes instead of double quotes. For example:
  echo 'This is a backslash: \ And this is a quote: " '
Of course if you do want variable substitution to take place then that
is not a good idea.
@end deffn

@deffn Command cat
The @code{cat} command sends the contents of files to standard output:
  cat file1 file2 file3 ...
No options are portable.
@end deffn

@deffn Command cmp
The @code{cmp} command compares two files. Always call with the option
@code{-s} and depend on the return status, not on whether output was
produced or not. To test the return code use an @code{if} construct
as in this example:
  if cmp -s file1 file2
  then
    echo "The files are the same"
  else
    echo "The files are different"
  fi
@end deffn

@deffn Command cp
The @code{cp} command copies a file to another file, or copies a set
of files under a directory:
  cp file newfile
  cp file1 file2 file3 ... directory
No options are portable. Especially the @code{-a} option. Instead of
  cp -a path1/dir1 path2/dir2
do:
  (cd path1 ; tar cf - dir1) | (cd path2 ; tar xf - dir2)
It is unlikely you will want to do this in an autoconf macro, but in case...
@end deffn

@deffn Command expr
The @code{expr} command allows you to do arithmetic with shell variables.
Don't use the pattern matching facilities of @code{expr} because they
are not as universal as its arithmetic capabilities. If you need matching
only for recognizing patterns, without any substitution, merely base your
code on the @code{case} construct. If you need pattern matching with
substitution, rather use @code{sed}. If you need @emph{arithmetic} then
and only then use @code{expr}.

For example you can increment the value of a shell variable by:
  a=1
  a=`expr $a+1`
You may also do more complex stuff like:
  a=1 b=3 c=5
  d=`expr ($a*$b)-(($c+3)/($b+1)+3)`
The variables in use are coerced into numbers. If that is not possible
then an error occurs.

If you wish to compare two numbers don't use the @code{test} options
for that because they are not portable. Instead go through @code{expr}.
For example a way to test if two numbers are equal is:
  if test `expr $a == $b` = 1
  then
    echo "they are equal"
  else
    echo "they are not equal"
  fi
You can similarly use the operators @code{<=}, @code{>=}, @code{!=},
@code{<}, @code{>}.
@end deffn

@deffn Command mv
The @code{mv} command renames a file or moves lots of files under
a directory and removes the originals. Be careful with this command.
  mv file newname
  mv file1 file2 file3 file4 directory
No options are portable.
@end deffn

@deffn Command grep
The @code{grep} command accepts a bunch of lines from standard input
and sends over to standard output only the lines that contain a certain
pattern. For example
  ls | grep *.html
will list only the files that end in @code{.html}.
The only portable flag you may use is the @code{-v} flag which has the
reverse effect. For example
  ls | grep -v *.html
will list all the files except for the files that end in @code{.html}.
@end deffn

@deffn Command pwd
The @code{pwd} sends the present working directory to the standard output.
Usually in Autoconf code we want to assign it to a variable as part of
an absolute pathname.
  foo=`pwd`/lib/foo
No options are portable.
@end deffn
@deffn Command mkdir
The @code{mkdir} command creates a directory. For example
  mkdir dir1
No options are portable.
@end deffn

@deffn Command rmdir
The @code{rmdir} command deletes an @emph{empty} directory. For example
  rmdir dir1
No options are portable.
@end deffn

@deffn Command rm
The @code{rm} command deletes files. For example
  rm file1 file2 file3
It is always a good idea to use the @code{-f} option which is portable
when you are just casually deleting files. This option will make sure that
you don't get error messages and/or the script does not abort if you
attempt to delete a file that does not exist. It will also force delete
on files that do not have write permissions but which are owned by the user
instead of prompting for a confirmation. So the recommended syntax is:
  rm -f file1 file2 file3
If you want to delete directories recursively and everything underneath them
then do:
  rm -rf dir1 dir2 dir3
Note that this is not supposed to follow symbolic links but don't risk it.
@end deffn

@deffn Command touch
The @code{touch} command will create an empty file, if one does not exist.
If it does exist it will update its timestamp.
  touch file1 file2 file3
No options are portable
@end deffn

@deffn Command ln
The @code{ln} command will create a symbolic link for a given file. 
However, in Autoconf code, don't use the @code{ln} command. Instead
use the @code{AC_LINK_FILES} macro:
  AC_LINK_FILES(source1 , dest1)
This makes @code{dest1} a link to @code{source1}.
You can also loop over many files:
  AC_LINK_FILES(source1 source2 source3 ... , dest1 dest2 dest3 ...)
This makes @code{dest1} a link to @code{source1}, 
@code{dest2} a link to @code{source2}, and so on.
If you want to use the @code{ln} command in a Makefile, then it
is preferable to use the syntax:
  ln -s source dest
if it is supported or the syntax
  ln source test
if the @code{-s} option is not supported. To determine that in your
@code{configure.in} call
  AC_PROG_LN_S
and in your Makefile invoke
  $(LN_S) source dest
instead.
Symbolic links can be great for gathering include files and libraries
in specific directories for building multi-directory packages.
@end deffn


/* config.h.in.  Generated from configure.ac by autoheader.  */

/* Define if building universal (internal helper macro) */
#undef AC_APPLE_UNIVERSAL_BUILD

/* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP
   systems. This function is required for `alloca.c' support on those systems.
   */
#undef CRAY_STACKSEG_END

/* Define to 1 if C++ has buggy for-loops */
#undef CXX_HAS_BUGGY_FOR_LOOPS

/* Define to 1 if C++ has no bool */
#undef CXX_HAS_NO_BOOL

/* Define to 1 if your C++ compiler doesn't accept -c and -o together. */
#undef CXX_NO_MINUS_C_MINUS_O

/* Define to 1 if using `alloca.c'. */
#undef C_ALLOCA

/* Define to 1 if the F77 compiler appends underscores */
#undef F77_APPEND_UNDERSCORE

/* Define to alternate name for `main' routine that is called from a `main' in
   the Fortran libraries. */
#undef F77_MAIN

/* Define to 1 if your Fortran compiler doesn't accept -c and -o together. */
#undef F77_NO_MINUS_C_MINUS_O

/* Define to 1 if the F77 compiler uses uppercase names */
#undef F77_UPPERCASE_NAMES

/* Define to dummy `main' function (if any) required to link to the Fortran
   libraries. */
#undef FC_DUMMY_MAIN

/* Define if F77 and FC dummy `main' functions are identical. */
#undef FC_DUMMY_MAIN_EQ_F77

/* Define to a macro mangling the given C identifier (in lower and upper
   case), which must not contain underscores, for linking with Fortran. */
#undef FC_FUNC

/* As FC_FUNC, but for C identifiers containing underscores. */
#undef FC_FUNC_

/* Define to alternate name for `main' routine that is called from a `main' in
   the Fortran libraries. */
#undef FC_MAIN

/* Define to 1 if your Fortran compiler doesn't accept -c and -o together. */
#undef FC_NO_MINUS_C_MINUS_O

/* Define to nothing if C supports flexible array members, and to 1 if it does
   not. That way, with a declaration like `struct s { int n; double
   d[FLEXIBLE_ARRAY_MEMBER]; };', the struct hack can be used with pre-C99
   compilers. When computing the size of such an object, don't use 'sizeof
   (struct s)' as it overestimates the size. Use 'offsetof (struct s, d)'
   instead. Don't use 'offsetof (struct s, d[0])', as this doesn't work with
   MSVC and with C++ compilers. */
#undef FLEXIBLE_ARRAY_MEMBER

/* Define to 1 if you have `alloca', as a function or macro. */
#undef HAVE_ALLOCA

/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
   */
#undef HAVE_ALLOCA_H

/* Define to 1 if you have the <assert.h> header file. */
#undef HAVE_ASSERT_H

/* Define to 1 if you have the <cpp.h> header file. */
#undef HAVE_CPP_H

/* Define if backslash-a works in C strings. */
#undef HAVE_C_BACKSLASH_A

/* Define to 1 if C supports variable-length arrays. */
#undef HAVE_C_VARARRAYS

/* Define to 1 if you have the `exit' function. */
#undef HAVE_EXIT

/* Define to 1 if you have the `getopt' function. */
#undef HAVE_GETOPT

/* Define to 1 if you have the <getopt.h> header file. */
#undef HAVE_GETOPT_H

/* Define to 1 if you have the `getopt_long' function. */
#undef HAVE_GETOPT_LONG

/* Define to 1 if you have the <inttypes.h> header file. */
#undef HAVE_INTTYPES_H

/* Define to 1 if you have the <iostream.h> header file. */
#undef HAVE_IOSTREAM_H

/* Define to 1 if you have the <libintl.h> header file. */
#undef HAVE_LIBINTL_H

/* Define to 1 if you have the <long-options.h> header file. */
#undef HAVE_LONG_OPTIONS_H

/* Define to 1 if your system has a GNU libc compatible `malloc' function, and
   to 0 otherwise. */
#undef HAVE_MALLOC

/* Define to 1 if you have the <memory.h> header file. */
#undef HAVE_MEMORY_H

/* Define to 1 if stdbool.h conforms to C99. */
#undef HAVE_STDBOOL_H

/* Define to 1 if you have the <stdint.h> header file. */
#undef HAVE_STDINT_H

/* Define to 1 if you have the <stdlib.h> header file. */
#undef HAVE_STDLIB_H

/* Define to 1 if you have the `strcat' function. */
#undef HAVE_STRCAT

/* Define to 1 if you have the `strcpy' function. */
#undef HAVE_STRCPY

/* Define to 1 if cpp supports the ANSI # stringizing operator. */
#undef HAVE_STRINGIZE

/* Define to 1 if you have the <strings.h> header file. */
#undef HAVE_STRINGS_H

/* Define to 1 if you have the <string.h> header file. */
#undef HAVE_STRING_H

/* Define to 1 if you have the `strlen' function. */
#undef HAVE_STRLEN

/* Define to 1 if you have the <sys/stat.h> header file. */
#undef HAVE_SYS_STAT_H

/* Define to 1 if you have the <sys/types.h> header file. */
#undef HAVE_SYS_TYPES_H

/* Define to 1 if typeof works with your compiler. */
#undef HAVE_TYPEOF

/* Define to 1 if you have the <unistd.h> header file. */
#undef HAVE_UNISTD_H

/* Define to 1 if you have the <xalloca.h> header file. */
#undef HAVE_XALLOCA_H

/* Define to 1 if the system has the type `_Bool'. */
#undef HAVE__BOOL

/* Define whether or not you want assertions */
#undef NDEBUG

/* Name of package */
#undef PACKAGE

/* Define to the address where bug reports for this package should be sent. */
#undef PACKAGE_BUGREPORT

/* Define to the full name of this package. */
#undef PACKAGE_NAME

/* Define to the full name and version of this package. */
#undef PACKAGE_STRING

/* Define to the one symbol short name of this package. */
#undef PACKAGE_TARNAME

/* Define to the home page for this package. */
#undef PACKAGE_URL

/* Define to the version of this package. */
#undef PACKAGE_VERSION

/* Define to 1 if the C compiler supports function prototypes. */
#undef PROTOTYPES

/* If using the C implementation of alloca, define if you know the
   direction of stack growth for your system; otherwise it will be
   automatically deduced at runtime.
	STACK_DIRECTION > 0 => grows toward higher addresses
	STACK_DIRECTION < 0 => grows toward lower addresses
	STACK_DIRECTION = 0 => direction of growth unknown */
#undef STACK_DIRECTION

/* Define to 1 if you have the ANSI C header files. */
#undef STDC_HEADERS

/* Enable extensions on AIX 3, Interix.  */
#ifndef _ALL_SOURCE
# undef _ALL_SOURCE
#endif
/* Enable GNU extensions on systems that have them.  */
#ifndef _GNU_SOURCE
# undef _GNU_SOURCE
#endif
/* Enable threading extensions on Solaris.  */
#ifndef _POSIX_PTHREAD_SEMANTICS
# undef _POSIX_PTHREAD_SEMANTICS
#endif
/* Enable extensions on HP NonStop.  */
#ifndef _TANDEM_SOURCE
# undef _TANDEM_SOURCE
#endif
/* Enable general extensions on Solaris.  */
#ifndef __EXTENSIONS__
# undef __EXTENSIONS__
#endif


/* Version number of package */
#undef VERSION

/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
   significant byte first (like Motorola and SPARC, unlike Intel). */
#if defined AC_APPLE_UNIVERSAL_BUILD
# if defined __BIG_ENDIAN__
#  define WORDS_BIGENDIAN 1
# endif
#else
# ifndef WORDS_BIGENDIAN
#  undef WORDS_BIGENDIAN
# endif
#endif

/* Define to 1 if the X Window System is missing or not being used. */
#undef X_DISPLAY_MISSING

/* string representing your operating system */
#undef YOUR_OS

/* Define to 1 if `lex' declares `yytext' as a `char *' by default, not a
   `char[]'. */
#undef YYTEXT_POINTER

/* Define to 1 if on MINIX. */
#undef _MINIX

/* Define to 2 if the system does not provide POSIX.1 features except with
   this defined. */
#undef _POSIX_1_SOURCE

/* Define to 1 if you need to in order for `stat' and other things to work. */
#undef _POSIX_SOURCE

/* Define to 1 if type `char' is unsigned and you are not using gcc.  */
#ifndef __CHAR_UNSIGNED__
# undef __CHAR_UNSIGNED__
#endif

/* Define like PROTOTYPES; this can be used by system headers. */
#undef __PROTOTYPES

/* Define to empty if `const' does not conform to ANSI C. */
#undef const

/* Define to `__inline__' or `__inline' if that's what the C compiler
   calls it, or to nothing if 'inline' is not supported under any name.  */
#ifndef __cplusplus
#undef inline
#endif

/* Define to rpl_malloc if the replacement function should be used. */
#undef malloc

/* Define to the equivalent of the C99 'restrict' keyword, or to
   nothing if this is not supported.  Do not define if restrict is
   supported directly.  */
#undef restrict
/* Work around a bug in Sun C++: it does not support _Restrict or
   __restrict__, even though the corresponding Sun C compiler ends up with
   "#define restrict _Restrict" or "#define restrict __restrict__" in the
   previous line.  Perhaps some future version of Sun C++ will work with
   restrict; if so, hopefully it defines __RESTRICT like Sun C does.  */
#if defined __SUNPRO_CC && !defined __RESTRICT
# define _Restrict
# define __restrict__
#endif

/* Define to `unsigned int' if <sys/types.h> does not define. */
#undef size_t

/* Define to __typeof__ if your compiler spells it that way. */
#undef typeof

/* Define to empty if the keyword `volatile' does not work. Warning: valid
   code using `volatile' can become incorrect without. Disable with care. */
#undef volatile


#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
// This config header section defines portability work-arounds for
// various proprietory C++ compilers.

// Workaround for compilers with buggy for-loop scoping
// That is quite a few compilers actually including recent versions of
// Dec Alpha cxx, HP-UX CC and SGI CC.
// The trivial "if" statement provides the correct scoping to the 
// for-loop:
# ifdef CXX_HAS_BUGGY_FOR_LOOPS
#  undef for
#  define for if(1) for
# endif /* CXX_HAS_BUGGY_FOR_LOOPS */

//
// Fortran-like integer looping macros
// these critters depend on the scoping work-around above
//
# define loop(COUNTER,BEGIN,END)  \
for (int COUNTER = BEGIN ; COUNTER <= END ; COUNTER ## ++)

# define inverse_loop(COUNTER,END,BEGIN) \
for (int COUNTER = END; COUNTER >= BEGIN; COUNTER ## --)

# define integer_loop(COUNTER,BEGIN,END,STEP) \
for (int COUNTER = BEGIN; COUNTER <= END; COUNTER += STEP)

//
// Class protection levels
// addictive syntactic sugar to make coding nicer:
//
# define pub public:
# define pro protected:
# define pri private:

//
// Every mathematician would like to know pi
// so this is as good a place as any to throw it in.
//
# ifndef pi
#  define pi 3.14159265358979324
# endif /* !pi */

//
// If the C++ compiler we use does NOT have bool, then
// the following is a near-perfect work-around. 
// You must make sure your code does not depend on "int" and "bool"
// being two different types, in overloading for instance.
//
# ifdef CXX_HAS_NO_BOOL
#  if !defined(bool) && !defined(true) && !defined(false)
#   define bool int
#   define true 1
#   define false 0
#  else
#   if defined(__GNUC__) && !defined(__STRICT_ANSI__) && defined(__cplusplus)
#    warning "we need bool, but cannot successfully (re)define it"
#   endif /* __GNUC__ && !__STRICT_ANSI__ && __cplusplus */
#  endif /* !bool && !true && !false */
# endif /* CXX_HAS_NO_BOOL */

// assertions:
# ifdef HAVE_ASSERT_H
#  include <assert.h>
# else
#  if defined(__GNUC__) && !defined(__STRICT_ANSI__) && defined(__cplusplus)
#   warning "this header expects <assert.h> to be included."
#  endif /* __GNUC__ && !__STRICT_ANSI__ && __cplusplus */
# endif /* HAVE_ASSERT_H */
#endif /* __cplusplus || !__STRICT_ANSI__ */
  


#ifndef f77func
#  if defined (F77_APPEND_UNDERSCORE)
#    if defined (F77_UPPERCASE_NAMES)
#      define f77func(f, F) F##_
#    else /* !F77_UPPERCASE_NAMES: */
#      define f77func(f, F) f##_
#    endif /* F77_UPPERCASE_NAMES */
#  else /* !F77_APPEND_UNDERSCORE: */
#    if defined (F77_UPPERCASE_NAMES)
#      define f77func(f, F) F
#    else /* !F77_UPPERCASE_NAMES: */
#      define f77func(f, F) f
#    endif /* F77_UPPERCASE_NAMES */
#  endif /* F77_APPEND_UNDERSCORE */
#endif /* !f77func */
  
